SCRIPT  /usr/share/nvim/runtime/ftplugin/verilog.vim
Sourced 1 time
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	Verilog HDL
                            " Maintainer:	Chih-Tsun Huang <cthuang@cs.nthu.edu.tw>
                            " Last Change:	2017 Aug 25 by Chih-Tsun Huang
                            "		2024 Jan 14 by Vim Project (browsefilter)
                            "		2024 May 20 by Riley Bruins <ribru17@gmail.com> (commentstring)
                            " URL:	    	http://www.cs.nthu.edu.tw/~cthuang/vim/ftplugin/verilog.vim
                            "
                            " Credits:
                            "   Suggestions for improvement, bug reports by
                            "     Shao <shaominghai2005@163.com>
                            
                            " Only do this when not done yet for this buffer
    1              0.000004 if exists("b:did_ftplugin")
                              finish
    1              0.000001 endif
                            
                            " Don't load another plugin for this buffer
    1              0.000002 let b:did_ftplugin = 1
                            
                            " Set 'cpoptions' to allow line continuations
    1              0.000002 let s:cpo_save = &cpo
    1              0.000008 set cpo&vim
                            
                            " Undo the plugin effect
    1              0.000003 let b:undo_ftplugin = "setlocal fo< com< tw< cms<"
                                \ . "| unlet! b:browsefilter b:match_ignorecase b:match_words"
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    1              0.000005 setlocal fo-=t fo+=croqlm1
                            
                            " Set 'comments' to format dashed lists in comments.
    1              0.000004 setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://
    1              0.000003 setlocal commentstring=//\ %s
                            
                            " Format comments to be up to 78 characters long
    1              0.000002 if &textwidth == 0 
    1              0.000004   setlocal tw=78
    1              0.000001 endif
                            
                            " Win32 and GTK can filter files in the browse dialog
    1              0.000007 if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
                              let b:browsefilter = "Verilog Source Files (*.v)\t*.v\n"
                              if has("win32")
                                let b:browsefilter .= "All Files (*.*)\t*\n"
                              else
                                let b:browsefilter .= "All Files (*)\t*\n"
                              endif
    1              0.000000 endif
                            
                            " Let the matchit plugin know what items can be matched.
    1              0.000002 if exists("loaded_matchit")
    1              0.000001   let b:match_ignorecase=0
    1              0.000008   let b:match_words=
                                \ '\<begin\>:\<end\>,' .
                                \ '\<case\>\|\<casex\>\|\<casez\>:\<endcase\>,' .
                                \ '\<module\>:\<endmodule\>,' .
                                \ '\<if\>:`\@<!\<else\>,' .
                                \ '\<function\>:\<endfunction\>,' .
                                \ '`ifn\?def\>:`elsif\>:`else\>:`endif\>,' .
                                \ '\<task\>:\<endtask\>,' .
                                \ '\<specify\>:\<endspecify\>,' .
                                \ '\<config\>:\<endconfig\>,' .
                                \ '\<generate\>:\<endgenerate\>,' .
                                \ '\<fork\>:\<join\>,' .
                                \ '\<primitive\>:\<endprimitive\>,' .
                                \ '\<table\>:\<endtable\>'
    1              0.000000 endif
                            
                            " Reset 'cpoptions' back to the user's setting
    1              0.000003 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save

SCRIPT  /usr/share/nvim/runtime/indent/verilog.vim
Sourced 1 time
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
                            " Language:     Verilog HDL
                            " Maintainer:	Chih-Tsun Huang <cthuang@cs.nthu.edu.tw>
                            " Last Change:	2017 Aug 25 by Chih-Tsun Huang
                            " 		2023 Aug 28 by Vim Project (undo_indent)
                            " URL:		    http://www.cs.nthu.edu.tw/~cthuang/vim/indent/verilog.vim
                            "
                            " Credits:
                            "   Suggestions for improvement, bug reports by
                            "     Takuya Fujiwara <tyru.exe@gmail.com>
                            "     Thilo Six <debian@Xk2c.de>
                            "     Leo Butlero <lbutler@brocade.com>
                            "
                            " Buffer Variables:
                            "     b:verilog_indent_modules : indenting after the declaration
                            "				 of module blocks
                            "     b:verilog_indent_width   : indenting width
                            "     b:verilog_indent_verbose : verbose to each indenting
                            "
                            
                            " Only load this indent file when no other was loaded.
    1              0.000002 if exists("b:did_indent")
                              finish
    1              0.000000 endif
    1              0.000001 let b:did_indent = 1
                            
    1              0.000005 setlocal indentexpr=GetVerilogIndent()
    1              0.000002 setlocal indentkeys=!^F,o,O,0),=begin,=end,=join,=endcase
    1              0.000002 setlocal indentkeys+==endmodule,=endfunction,=endtask,=endspecify
    1              0.000002 setlocal indentkeys+==endconfig,=endgenerate,=endprimitive,=endtable
    1              0.000002 setlocal indentkeys+==`else,=`elsif,=`endif
                            
    1              0.000001 let b:undo_indent = "setlocal indentexpr< indentkeys<"
                            
                            " Only define the function once.
    1              0.000003 if exists("*GetVerilogIndent")
    1              0.000001   finish
                            endif
                            
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            function GetVerilogIndent()
                            
                              if exists('b:verilog_indent_width')
                                let offset = b:verilog_indent_width
                              else
                                let offset = shiftwidth()
                              endif
                              if exists('b:verilog_indent_modules')
                                let indent_modules = offset
                              else
                                let indent_modules = 0
                              endif
                            
                              " Find a non-blank line above the current line.
                              let lnum = prevnonblank(v:lnum - 1)
                            
                              " At the start of the file use zero indent.
                              if lnum == 0
                                return 0
                              endif
                            
                              let lnum2 = prevnonblank(lnum - 1)
                              let curr_line  = getline(v:lnum)
                              let last_line  = getline(lnum)
                              let last_line2 = getline(lnum2)
                              let ind  = indent(lnum)
                              let ind2 = indent(lnum - 1)
                              let offset_comment1 = 1
                              " Define the condition of an open statement
                              "   Exclude the match of //, /* or */
                              let vlog_openstat = '\(\<or\>\|\([*/]\)\@<![*(,{><+-/%^&|!=?:]\([*/]\)\@!\)'
                              " Define the condition when the statement ends with a one-line comment
                              let vlog_comment = '\(//.*\|/\*.*\*/\s*\)'
                              if exists('b:verilog_indent_verbose')
                                let vverb_str = 'INDENT VERBOSE:'
                                let vverb = 1
                              else
                                let vverb = 0
                              endif
                            
                              " Indent according to last line
                              " End of multiple-line comment
                              if last_line =~ '\*/\s*$' && last_line !~ '/\*.\{-}\*/'
                                let ind = ind - offset_comment1
                                if vverb
                                  echo vverb_str "De-indent after a multiple-line comment."
                                endif
                            
                              " Indent after if/else/for/case/always/initial/specify/fork blocks
                              " Note: We exclude '`if' or '`else' and consider 'end else' 
                              "       'end if' is redundant here
                              elseif last_line =~ '^\s*\(end\)\=\s*`\@<!\<\(if\|else\)\>' ||
                                \ last_line =~ '^\s*\<\(for\|case\%[[zx]]\)\>' ||
                                \ last_line =~ '^\s*\<\(always\|initial\)\>' ||
                                \ last_line =~ '^\s*\<\(specify\|fork\)\>'
                                if last_line !~ '\(;\|\<end\>\)\s*' . vlog_comment . '*$' ||
                                  \ last_line =~ '\(//\|/\*\).*\(;\|\<end\>\)\s*' . vlog_comment . '*$'
                                  let ind = ind + offset
                                  if vverb | echo vverb_str "Indent after a block statement." | endif
                                endif
                              " Indent after function/task/config/generate/primitive/table blocks
                              elseif last_line =~ '^\s*\<\(function\|task\|config\|generate\|primitive\|table\)\>'
                                if last_line !~ '\<end\>\s*' . vlog_comment . '*$' ||
                                  \ last_line =~ '\(//\|/\*\).*\(;\|\<end\>\)\s*' . vlog_comment . '*$'
                                  let ind = ind + offset
                                  if vverb
                            	echo vverb_str "Indent after function/task block statement."
                                  endif
                                endif
                            
                              " Indent after module/function/task/specify/fork blocks
                              elseif last_line =~ '^\s*\<module\>'
                                let ind = ind + indent_modules
                                if vverb && indent_modules
                                  echo vverb_str "Indent after module statement."
                                endif
                                if last_line =~ '[(,]\s*' . vlog_comment . '*$' &&
                                  \ last_line !~ '\(//\|/\*\).*[(,]\s*' . vlog_comment . '*$'
                                  let ind = ind + offset
                                  if vverb
                            	echo vverb_str "Indent after a multiple-line module statement."
                                  endif
                                endif
                            
                              " Indent after a 'begin' statement
                              elseif last_line =~ '\(\<begin\>\)\(\s*:\s*\w\+\)*' . vlog_comment . '*$' &&
                                \ last_line !~ '\(//\|/\*\).*\(\<begin\>\)' &&
                                \ ( last_line2 !~ vlog_openstat . '\s*' . vlog_comment . '*$' ||
                                \ last_line2 =~ '^\s*[^=!]\+\s*:\s*' . vlog_comment . '*$' )
                                let ind = ind + offset
                                if vverb | echo vverb_str "Indent after begin statement." | endif
                            
                              " De-indent for the end of one-line block
                              elseif ( last_line !~ '\<begin\>' ||
                                \ last_line =~ '\(//\|/\*\).*\<begin\>' ) &&
                                \ last_line2 =~ '\<\(`\@<!if\|`\@<!else\|for\|always\|initial\)\>.*' .
                                  \ vlog_comment . '*$' &&
                                \ last_line2 !~
                                  \ '\(//\|/\*\).*\<\(`\@<!if\|`\@<!else\|for\|always\|initial\)\>' &&
                                \ last_line2 !~ vlog_openstat . '\s*' . vlog_comment . '*$' &&
                                \ ( last_line2 !~ '\<begin\>' ||
                                \ last_line2 =~ '\(//\|/\*\).*\<begin\>' )
                                let ind = ind - offset
                                if vverb
                                  echo vverb_str "De-indent after the end of one-line statement."
                                endif
                            
                                " Multiple-line statement (including case statement)
                                " Open statement
                                "   Ident the first open line
                                elseif  last_line =~ vlog_openstat . '\s*' . vlog_comment . '*$' &&
                                  \ last_line !~ '\(//\|/\*\).*' . vlog_openstat . '\s*$' &&
                                  \ last_line2 !~ vlog_openstat . '\s*' . vlog_comment . '*$'
                                  let ind = ind + offset
                                  if vverb | echo vverb_str "Indent after an open statement." | endif
                            
                                " Close statement
                                "   De-indent for an optional close parenthesis and a semicolon, and only
                                "   if there exists precedent non-whitespace char
                                elseif last_line =~ ')*\s*;\s*' . vlog_comment . '*$' &&
                                  \ last_line !~ '^\s*)*\s*;\s*' . vlog_comment . '*$' &&
                                  \ last_line !~ '\(//\|/\*\).*\S)*\s*;\s*' . vlog_comment . '*$' &&
                                  \ ( last_line2 =~ vlog_openstat . '\s*' . vlog_comment . '*$' &&
                                  \ last_line2 !~ ';\s*//.*$') &&
                                  \ last_line2 !~ '^\s*' . vlog_comment . '$'
                                  let ind = ind - offset
                                  if vverb | echo vverb_str "De-indent after a close statement." | endif
                            
                              " `ifdef or `ifndef or `elsif or `else
                              elseif last_line =~ '^\s*`\<\(ifn\?def\|elsif\|else\)\>'
                                let ind = ind + offset
                                if vverb
                                  echo vverb_str "Indent after a `ifdef or `ifndef or `elsif or `else statement."
                                endif
                            
                              endif
                            
                              " Re-indent current line
                            
                              " De-indent on the end of the block
                              " join/end/endcase/endfunction/endtask/endspecify
                              if curr_line =~ '^\s*\<\(join\|end\|endcase\)\>' ||
                                \ curr_line =~ '^\s*\<\(endfunction\|endtask\|endspecify\)\>' ||
                                \ curr_line =~ '^\s*\<\(endconfig\|endgenerate\|endprimitive\|endtable\)\>'
                                let ind = ind - offset
                                if vverb | echo vverb_str "De-indent the end of a block." | endif
                              elseif curr_line =~ '^\s*\<endmodule\>'
                                let ind = ind - indent_modules
                                if vverb && indent_modules
                                  echo vverb_str "De-indent the end of a module."
                                endif
                            
                              " De-indent on a stand-alone 'begin'
                              elseif curr_line =~ '^\s*\<begin\>'
                                if last_line !~ '^\s*\<\(function\|task\|specify\|module\|config\|generate\|primitive\|table\)\>' &&
                                  \ last_line !~ '^\s*\()*\s*;\|)\+\)\s*' . vlog_comment . '*$' &&
                                  \ ( last_line =~
                            	\ '\<\(`\@<!if\|`\@<!else\|for\|case\%[[zx]]\|always\|initial\)\>' ||
                                  \ last_line =~ ')\s*' . vlog_comment . '*$' ||
                                  \ last_line =~ vlog_openstat . '\s*' . vlog_comment . '*$' )
                                  let ind = ind - offset
                                  if vverb
                            	echo vverb_str "De-indent a stand alone begin statement."
                                  endif
                                endif
                            
                              " De-indent after the end of multiple-line statement
                              elseif curr_line =~ '^\s*)' &&
                                \ ( last_line =~ vlog_openstat . '\s*' . vlog_comment . '*$' ||
                                \ last_line !~ vlog_openstat . '\s*' . vlog_comment . '*$' &&
                                \ last_line2 =~ vlog_openstat . '\s*' . vlog_comment . '*$' )
                                let ind = ind - offset
                                if vverb
                                  echo vverb_str "De-indent the end of a multiple statement."
                                endif
                            
                              " De-indent `elsif or `else or `endif
                              elseif curr_line =~ '^\s*`\<\(elsif\|else\|endif\)\>'
                                let ind = ind - offset
                                if vverb | echo vverb_str "De-indent `elsif or `else or `endif statement." | endif
                            
                              endif
                            
                              " Return the indentation
                              return ind
                            endfunction
                            
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            " vim:sw=2

SCRIPT  /home/awjl/Software/vtags-3.11/vtags_vim_api.vim
Sourced 8 times
Total time:   0.008793
 Self time:   0.000962

count  total (s)   self (s)
                            """
                            " http://www.vim.org/scripts/script.php?script_id=5494
                            """
                            "===============================================================================
                            " BSD 2-Clause License
                            " 
                            " Copyright (c) 2016, CaoJun
                            " All rights reserved.
                            " 
                            " Redistribution and use in source and binary forms, with or without
                            " modification, are permitted provided that the following conditions are met:
                            " 
                            " * Redistributions of source code must retain the above copyright notice, this
                            "   list of conditions and the following disclaimer.
                            " 
                            " * Redistributions in binary form must reproduce the above copyright notice,
                            "   this list of conditions and the following disclaimer in the documentation
                            "   and/or other materials provided with the distribution.
                            " 
                            " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            " AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            " IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            " DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            " FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            " DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            " SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            " CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            " OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            " OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            "===============================================================================
                            
    8              0.000055 let s:path = expand('<sfile>:p:h')
                            
    8              0.000016 function! VimPythonExtend()
                            if has('python')
                            python << EOF
                            import sys
                            import os
                            import vim
                            vtags_install_path = vim.eval('s:path')
                            assert(os.path.isdir(vtags_install_path))
                            sys.path.insert(0,vtags_install_path)
                            from Lib.ExceptionLib import *
                            
                            vim.command("let s:vtags_active = 0")
                            try:
                                from InlineLib.InlineAPI import *
                                vim.command("let s:vtags_active = 1")
                            except VtagsDBNotFoundExcept:
                                pass
                            except VtagsUnsupportFileExcept:
                                pass
                            
                            EOF
                            elseif has('python3')
                            python3 << EOF
                            import sys
                            import os
                            import vim
                            vtags_install_path = vim.eval('s:path')
                            assert(os.path.isdir(vtags_install_path))
                            sys.path.insert(0,vtags_install_path)
                            from Lib.ExceptionLib import *
                            
                            vim.command("let s:vtags_active = 0")
                            try:
                                from InlineLib.InlineAPI import *
                                vim.command("let s:vtags_active = 1")
                            except VtagsDBNotFoundExcept:
                                pass
                            except VtagsUnsupportFileExcept:
                                pass
                            
                            EOF
                            endif
                            endfunction
                            
                            "vi_HDLTags_begin-----------------------------------
    8   0.007883   0.000052 call VimPythonExtend()
    8              0.000024 if s:vtags_active == 1
    8              0.000034     if has('python')
                                    map gi                   :py  try_go_into_submodule()           <CR>
                                    map gu                   :py  try_go_upper_module()             <CR>
                                    map mt                   :py  try_print_module_trace()          <CR>
                                    map ct                   :py  clear_trace()                     <CR>
                                    map <Space><Left>        :py  try_trace_signal_sources()        <CR>
                                    map <Space><Right>       :py  try_trace_signal_destinations()   <CR>
                                    map <Space><Down>        :py  try_roll_back()                   <CR>
                                    map <Space><Up>          :py  try_go_forward()                  <CR>
                                    map <Space>v             :py  try_show_frame()                  <CR> 
                                    map <Space>c             :py  try_add_check_point()             <CR> 
                                    map <Space>b             :py  try_add_base_module()             <CR> 
                                    map <Space>              :py  try_space_operation()             <CR>
                                    map <Space>h             :py  try_hold_current_win()            <CR>
                                    map <Space>d             :py  try_del_operation()               <CR>
                                    map <Space>s             :py  try_save_env_snapshort()          <CR>
                                    map <Space>r             :py  try_reload_env_snapshort()        <CR>
                                    map <Space>q             :py  try_close_all_windows()           <CR>
    8              0.000030     elseif has('python3')
    8              0.000098         map gi                   :py3 try_go_into_submodule()           <CR>
    8              0.000030         map gu                   :py3 try_go_upper_module()             <CR>
    8              0.000023         map mt                   :py3 try_print_module_trace()          <CR>
    8              0.000023         map ct                   :py3 clear_trace()                     <CR>
    8              0.000042         map <Space>v             :py3 try_show_frame()                  <CR> 
                                    "map <Space><Left>        :py3 try_trace_signal_sources()        <CR>
                                    "map <Space><Right>       :py3 try_trace_signal_destinations()   <CR>
                                    "map <Space><Down>        :py3 try_roll_back()                   <CR>
                                    "map <Space><Up>          :py3 try_go_forward()                  <CR>
    8              0.000027         map <Space>c             :py3 try_add_check_point()             <CR> 
    8              0.000019         map <Space>b             :py3 try_add_base_module()             <CR> 
    8              0.000020         map <Space>              :py3 try_space_operation()             <CR>
    8              0.000019         map <Space>h             :py3 try_hold_current_win()            <CR>
    8              0.000017         map <Space>d             :py3 try_del_operation()               <CR>
    8              0.000018         map <Space>s             :py3 try_save_env_snapshort()          <CR>
    8              0.000017         map <Space>r             :py3 try_reload_env_snapshort()        <CR>
    8              0.000017         map <Space>q             :py3 try_close_all_windows()           <CR>
    8              0.000004     endif
    8              0.000003 endif
                            "vi_HDLTags_end-------------------------------------

FUNCTION  <SNR>17_notify()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/client.vim:191
Called 310 times
Total time:   0.018064
 Self time:   0.016592

count  total (s)   self (s)
  310   0.003427   0.001955   let channel = coc#client#get_channel(self)
  310              0.000378   if empty(channel)
                                return ''
  310              0.000082   endif
  310              0.000210   try
  310              0.000178     if s:is_vim
                                  call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
  310              0.000143     else
  310              0.007168       call call('rpcnotify', [channel, a:method] + a:args)
  310              0.000209     endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0)
                                    return
                                  endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                endif
  310              0.000217   endtry

FUNCTION  <SNR>61_RunIfExecutable()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/engine.vim:556
Called 1 time
Total time:   0.002098
 Self time:   0.000044

count  total (s)   self (s)
    1   0.000007   0.000004     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:RunIfExecutable(       a:buffer,       a:linter,       a:lint_file,       executable   )}
                            
                                    return 1
    1              0.000000     endif
                            
    1   0.000013   0.000005     if ale#engine#IsExecutable(a:buffer, a:executable)
                                    " Use different job types for file or linter jobs.
    1              0.000001         let l:job_type = a:lint_file ? 'file_linter' : 'linter'
    1              0.000002         call setbufvar(a:buffer, 'ale_job_type', l:job_type)
                            
                                    " Get the cwd for the linter and set it before we call GetCommand.
                                    " This will ensure that ale#command#Run uses it by default.
    1   0.000008   0.000004         let l:cwd = ale#linter#GetCwd(a:buffer, a:linter)
                            
    1              0.000001         if l:cwd isnot v:null
                                        call ale#command#SetCwd(a:buffer, l:cwd)
    1              0.000000         endif
                            
    1   0.000031   0.000004         let l:command = ale#linter#GetCommand(a:buffer, a:linter)
                            
    1              0.000001         if l:cwd isnot v:null
                                        call ale#command#ResetCwd(a:buffer)
    1              0.000000         endif
                            
    1              0.000006         let l:options = {   'cwd': l:cwd,   'executable': a:executable,   'buffer': a:buffer,   'linter': a:linter,   'output_stream': get(a:linter, 'output_stream', 'stdout'),   'read_buffer': a:linter.read_buffer,   'lint_file': a:lint_file,}
                            
    1   0.002017   0.000006         return s:RunJob(l:command, l:options)
                                endif
                            
                                return 0

FUNCTION  coc_explorer#resize()
    Defined: ~/.config/coc/extensions/node_modules/coc-explorer/autoload/coc_explorer.vim:90
Called 2 times
Total time:   0.000082
 Self time:   0.000037

count  total (s)   self (s)
    2              0.000004   if a:position.name ==# 'tab'
                                return
    2              0.000001   endif
    2              0.000002   if a:position.name ==# 'floating'
                                call coc_explorer#float#resize(a:bufnr, a:options)
                                return
    2              0.000001   endif
    2   0.000032   0.000011   call setbufvar(a:bufnr, '&winfixwidth', 1)
    2   0.000036   0.000012   call coc_explorer#win#set_width(bufwinid(a:bufnr), a:options.width)

FUNCTION  ale#command#SetCwd()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/command.vim:34
Called 1 time
Total time:   0.000013
 Self time:   0.000006

count  total (s)   self (s)
    1   0.000011   0.000004     call ale#command#InitData(a:buffer)
    1              0.000002     let s:buffer_data[a:buffer].cwd = a:cwd

FUNCTION  ale#events#LintOnEnter()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/events.vim:42
Called 3 times
Total time:   0.003805
 Self time:   0.000057

count  total (s)   self (s)
                                " Unmark a file as being changed outside of Vim after we try to check it.
    3              0.000012     call setbufvar(a:buffer, 'ale_file_changed', 0)
                            
    3   0.000058   0.000019     if ale#Var(a:buffer, 'enabled') && g:ale_lint_on_enter
    3   0.003726   0.000017         call ale#Queue(0, 'lint_file', a:buffer)
    3              0.000001     endif

FUNCTION  <SNR>50_Lint()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale.vim:96
Called 10 times
Total time:   0.005739
 Self time:   0.000691

count  total (s)   self (s)
                                " Use the filetype from the buffer
   10              0.000151     let l:filetype = getbufvar(a:buffer, '&filetype')
   10   0.002458   0.000077     let l:linters = ale#linter#Get(l:filetype)
                            
   10   0.000201   0.000096     let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
   10   0.000114   0.000041     let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
                            
                                " Load code to ignore linters only if we need to.
   10              0.000052     if (   !empty(l:ignore_config)   || l:disable_lsp is 1   || l:disable_lsp is v:true   || (l:disable_lsp is# 'auto' && get(g:, 'lspconfig', 0)))
                                    let l:linters = ale#engine#ignore#Exclude(   l:filetype,   l:linters,   l:ignore_config,   l:disable_lsp,)
   10              0.000004     endif
                            
                                " Tell other sources that they can start checking the buffer now.
   10              0.000021     let g:ale_want_results_buffer = a:buffer
   10   0.000091   0.000060     silent doautocmd <nomodeline> User ALEWantResults
   10              0.000019     unlet! g:ale_want_results_buffer
                            
                                " Don't set up buffer data and so on if there are no linters to run.
   10              0.000037     if !has_key(g:ale_buffer_info, a:buffer) && empty(l:linters)
    9              0.000006         return
    1              0.000000     endif
                            
                                " Clear lint_file linters, or only run them if the file exists.
    1              0.000015     let l:lint_file = empty(l:linters)   || (a:should_lint_file && filereadable(expand('#' . a:buffer . ':p')))
                            
    1   0.002467   0.000007     call ale#engine#RunLinters(a:buffer, l:linters, l:lint_file)

FUNCTION  ale#linter#Get()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/linter.vim:374
Called 10 times
Total time:   0.002381
 Self time:   0.000972

count  total (s)   self (s)
   10              0.000023     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
   20              0.000108     for l:original_filetype in split(a:original_filetypes, '\.')
   10   0.000629   0.000072         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
   10   0.000271   0.000059         let l:linter_names = s:GetLinterNames(l:original_filetype)
   10   0.000740   0.000100         let l:all_linters = ale#linter#GetAll(l:filetype)
   10              0.000012         let l:filetype_linters = []
                            
   10              0.000023         if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
                                        let l:filetype_linters = l:all_linters
   10              0.000015         elseif type(l:linter_names) is v:t_list
                                        " Select only the linters we or the user has specified.
   17              0.000022             for l:linter in l:all_linters
    7              0.000016                 let l:name_list = [l:linter.name] + l:linter.aliases
                            
   14              0.000009                 for l:name in l:name_list
    8              0.000010                     if index(l:linter_names, l:name) >= 0
    1              0.000002                         call add(l:filetype_linters, l:linter)
    1              0.000000                         break
    7              0.000002                     endif
   14              0.000004                 endfor
   17              0.000005             endfor
   10              0.000007         endif
                            
   10              0.000022         call extend(l:possibly_duplicated_linters, l:filetype_linters)
   20              0.000013     endfor
                            
   10              0.000011     let l:name_list = []
   10              0.000011     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
   11              0.000024     for l:linter in reverse(l:possibly_duplicated_linters)
    1              0.000002         if index(l:name_list, l:linter.name) < 0
    1              0.000002             call add(l:name_list, l:linter.name)
    1              0.000001             call add(l:combined_linters, l:linter)
    1              0.000000         endif
   11              0.000005     endfor
                            
   10              0.000013     return reverse(l:combined_linters)

FUNCTION  coc#highlight#add_highlight()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/highlight.vim:257
Called 472 times
Total time:   0.010574
 Self time:   0.010574

count  total (s)   self (s)
  472              0.000937   let opts = get(a:, 1, {})
  472              0.000882   let priority = get(opts, 'priority', v:null)
  472              0.000350   if !s:is_vim
  472              0.000466     if s:set_extmark && a:src_id != -1
                                  " get(opts, 'start_incl', 0) ? v:true : v:false,
                                  try
                                    call nvim_buf_set_extmark(a:bufnr, a:src_id, a:line, a:col_start, { 'end_col': a:col_end, 'hl_group': a:hl_group, 'hl_mode': get(opts, 'combine', 1) ? 'combine' : 'replace', 'right_gravity': v:true, 'end_right_gravity': v:false, 'priority': type(priority) == 0 ?  min([priority, 4096]) : 4096, })
                                  catch /^Vim\%((\a\+)\)\=:E5555/
                                    " the end_col could be invalid, ignore this error
                                  endtry
  472              0.000147     else
  472              0.002180       call nvim_buf_add_highlight(a:bufnr, a:src_id, a:hl_group, a:line, a:col_start, a:col_end)
  472              0.000179     endif
                              else
                                if hlexists(a:hl_group)
                                  call coc#api#exec('buf_add_highlight', [a:bufnr, a:src_id, a:hl_group, a:line, a:col_start, a:col_end, opts])
                                endif
  472              0.000134   endif

FUNCTION  coc#util#do_autocmd()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/util.vim:338
Called 6 times
Total time:   0.000842
 Self time:   0.000140

count  total (s)   self (s)
    6              0.000086   if exists('#User#'.a:name)
    6   0.000740   0.000038     exe 'doautocmd <nomodeline> User '.a:name
    6              0.000003   endif

FUNCTION  coc#client#get_channel()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/client.vim:147
Called 313 times
Total time:   0.001486
 Self time:   0.001486

count  total (s)   self (s)
  313              0.000405   if s:is_vim
                                return a:client['channel']
  313              0.000102   endif
  313              0.000374   return a:client['chan_id']

FUNCTION  coc_explorer#util#buf_set_lines_skip_cursor()
    Defined: ~/.config/coc/extensions/node_modules/coc-explorer/autoload/coc_explorer/util.vim:28
Called 13 times
Total time:   0.002136
 Self time:   0.001945

count  total (s)   self (s)
   13              0.000140   if !s:is_nvim && !has('patch-8.2.1997') && &buftype == 'terminal'
                                return
   13              0.000010   endif
                            
   13   0.000316   0.000222   call setbufvar(a:bufnr, '&modifiable', 1)
   13   0.000095   0.000060   call setbufvar(a:bufnr, '&readonly', 0)
                            
   13              0.000012   try
   13              0.000012     if s:is_nvim
   13              0.000034       let cursor = v:null
   13              0.000027       let winid = bufwinid(a:bufnr)
   13              0.000015       if winid >= 0
   11              0.000040         let cursor = nvim_win_get_cursor(winid)
   13              0.000006       endif
   13              0.000958       call nvim_buf_set_lines(a:bufnr, a:start, a:end, a:strict_indexing, a:lines)
   13              0.000017       if winid >= 0
   11              0.000006         try
   11              0.000048           call nvim_win_set_cursor(winid, cursor)
                                    catch
   11              0.000008         endtry
   13              0.000005       endif
                                else
                                  call coc#api#call('buf_set_lines', [a:bufnr, a:start, a:end, a:strict_indexing, a:lines])
   13              0.000006     endif
                              catch
   13              0.000006   endtry
                            
   13   0.000115   0.000078   call setbufvar(a:bufnr, '&readonly', 1)
   13   0.000069   0.000044   call setbufvar(a:bufnr, '&modifiable', 0)

FUNCTION  <SNR>61_RunJob()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/engine.vim:430
Called 1 time
Total time:   0.002011
 Self time:   0.000059

count  total (s)   self (s)
    1   0.000006   0.000003     if ale#command#IsDeferred(a:command)
                                    let a:command.result_callback = {   command -> s:RunJob(command, a:options)}
                            
                                    return 1
    1              0.000000     endif
                            
    1              0.000001     let l:command = a:command
                            
    1              0.000001     if empty(l:command)
                                    return 0
    1              0.000000     endif
                            
    1              0.000001     let l:cwd = a:options.cwd
    1              0.000001     let l:executable = a:options.executable
    1              0.000001     let l:buffer = a:options.buffer
    1              0.000001     let l:linter = a:options.linter
    1              0.000001     let l:output_stream = a:options.output_stream
    1              0.000002     let l:read_buffer = a:options.read_buffer && !a:options.lint_file
    1              0.000002     let l:info = g:ale_buffer_info[l:buffer]
                            
    1              0.000006     let l:Callback = function('s:HandleExit', [{   'linter': l:linter,   'executable': l:executable,}])
    1   0.001948   0.000015     let l:result = ale#command#Run(l:buffer, l:command, l:Callback, {   'cwd': l:cwd,   'output_stream': l:output_stream,   'executable': l:executable,   'read_buffer': l:read_buffer,   'log_output': 1,   'filename_mappings': ale#GetFilenameMappings(l:buffer, l:linter.name),})
                            
                                " Only proceed if the job is being run.
    1              0.000001     if empty(l:result)
                                    return 0
    1              0.000000     endif
                            
    1   0.000023   0.000011     call ale#engine#MarkLinterActive(l:info, l:linter)
                            
    1   0.000008   0.000003     silent doautocmd <nomodeline> User ALEJobStarted
                            
    1              0.000001     return 1

FUNCTION  ale#cursor#Echom()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/cursor.vim:14
Called 1 time
Total time:   0.000863
 Self time:   0.000142

count  total (s)   self (s)
    1              0.000002     if mode() is# 'n'
                                    " no-custom-checks
    1   0.000860   0.000139         exec "norm! :echom a:message\n"
    1              0.000001     endif

FUNCTION  <SNR>61_GetLintFileValues()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/engine.vim:636
Called 1 time
Total time:   0.002405
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000001     let l:deferred_list = []
    1              0.000001     let l:new_slots = []
                            
    2              0.000002     for [l:lint_file, l:linter] in a:slots
    1   0.000008   0.000006         while ale#command#IsDeferred(l:lint_file) && has_key(l:lint_file, 'value')
                                        " If we've already computed the return value, use it.
                                        let l:lint_file = l:lint_file.value
    1              0.000000         endwhile
                            
    1   0.000005   0.000003         if ale#command#IsDeferred(l:lint_file)
                                        " If we are going to return the result later, wait for it.
                                        call add(l:deferred_list, l:lint_file)
    1              0.000000         else
                                        " If we have the value now, coerce it to 0 or 1.
    1              0.000001             let l:lint_file = l:lint_file is 1
    1              0.000000         endif
                            
    1              0.000002         call add(l:new_slots, [l:lint_file, l:linter])
    2              0.000001     endfor
                            
    1              0.000001     if !empty(l:deferred_list)
                                    for l:deferred in l:deferred_list
                                        let l:deferred.result_callback =   {-> s:GetLintFileValues(l:new_slots, a:Callback)}
                                    endfor
    1              0.000000     else
    1   0.002363   0.000004         call a:Callback(l:new_slots)
    1              0.000000     endif

FUNCTION  coc#highlight#create_namespace()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/highlight.vim:601
Called 472 times
Total time:   0.001066
 Self time:   0.001066

count  total (s)   self (s)
  472              0.000549   if type(a:key) == 0
  472              0.000338     return a:key
                              endif
                              if has_key(s:namespace_map, a:key)
                                return s:namespace_map[a:key]
                              endif
                              if has('nvim')
                                let s:namespace_map[a:key] = nvim_create_namespace('coc-'.a:key)
                              else
                                let s:namespace_map[a:key] = s:ns_id
                                let s:ns_id = s:ns_id + 1
                              endif
                              return s:namespace_map[a:key]

FUNCTION  <SNR>71_WinFindBuf()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/list.vim:96
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000005     return exists('*win_findbuf') ? win_findbuf(str2nr(a:buffer)) : [0]

FUNCTION  <SNR>61_HandleExit()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/engine.vim:151
Called 1 time
Total time:   0.001314
 Self time:   0.000062

count  total (s)   self (s)
    1              0.000003     let l:buffer_info = get(g:ale_buffer_info, a:buffer)
                            
    1              0.000001     if empty(l:buffer_info)
                                    return
    1              0.000000     endif
                            
    1              0.000001     let l:linter = a:job_info.linter
    1              0.000001     let l:executable = a:job_info.executable
                            
                                " Remove this job from the list.
    1   0.000011   0.000006     call ale#engine#MarkLinterInactive(l:buffer_info, l:linter.name)
                            
                                " Stop here if we land in the handle for a job completing if we're in
                                " a sandbox.
    1   0.000020   0.000003     if ale#util#InSandbox()
                                    return
    1              0.000000     endif
                            
    1              0.000005     if has('nvim') && !empty(a:output) && empty(a:output[-1])
                                    call remove(a:output, -1)
    1              0.000000     endif
                            
    1              0.000000     try
    1   0.000207   0.000024         let l:loclist = ale#util#GetFunction(l:linter.callback)(a:buffer, a:output)
                                " Handle the function being unknown, or being deleted.
                                catch /E700/
                                    let l:loclist = []
    1              0.000001     endtry
                            
    1   0.001056   0.000008     call ale#engine#HandleLoclist(l:linter.name, a:buffer, l:loclist, 0)

FUNCTION  <SNR>64_NeoVimCallback()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/job.vim:29
Called 3 times
Total time:   0.001736
 Self time:   0.000126

count  total (s)   self (s)
    3              0.000014     let l:info = s:job_map[a:job]
                            
    3              0.000005     if a:event is# 'stdout'
                                    let l:info.out_cb_line = ale#util#JoinNeovimOutput(   a:job,   l:info.out_cb_line,   a:data,   l:info.mode,   ale#util#GetFunction(l:info.out_cb),)
    3              0.000004     elseif a:event is# 'stderr'
    2   0.000182   0.000029         let l:info.err_cb_line = ale#util#JoinNeovimOutput(   a:job,   l:info.err_cb_line,   a:data,   l:info.mode,   ale#util#GetFunction(l:info.err_cb),)
    1              0.000000     else
    1              0.000003         if has_key(l:info, 'out_cb') && !empty(l:info.out_cb_line)
                                        call ale#util#GetFunction(l:info.out_cb)(a:job, l:info.out_cb_line)
    1              0.000000         endif
                            
    1              0.000002         if has_key(l:info, 'err_cb') && !empty(l:info.err_cb_line)
                                        call ale#util#GetFunction(l:info.err_cb)(a:job, l:info.err_cb_line)
    1              0.000000         endif
                            
    1              0.000001         try
    1   0.001465   0.000008             call ale#util#GetFunction(l:info.exit_cb)(a:job, a:data)
    1              0.000001         finally
                                        " Automatically forget about the job after it's done.
    1              0.000002             if has_key(s:job_map, a:job)
    1              0.000002                 call remove(s:job_map, a:job)
    1              0.000000             endif
    1              0.000000         endtry
    3              0.000001     endif

FUNCTION  ale_linters#verilog#verilator#Handle()
    Defined: ~/.local/share/nvim/lazy/ale/ale_linters/verilog/verilator.vim:17
Called 1 time
Total time:   0.000179
 Self time:   0.000050

count  total (s)   self (s)
                                " Look for lines like the following.
                                "
                                " %Error: addr_gen.v:3: syntax error, unexpected IDENTIFIER
                                " %Warning-WIDTH: addr_gen.v:26: Operator ASSIGNDLY expects 12 bits on the Assign RHS, but Assign RHS's CONST '20'h0' generates 20 bits.
                                " %Warning-UNUSED: test.v:3: Signal is not used: a
                                " %Warning-UNDRIVEN: test.v:3: Signal is not driven: clk
                                " %Warning-UNUSED: test.v:4: Signal is not used: dout
                                " %Warning-BLKSEQ: test.v:10: Blocking assignments (=) in sequential (flop or latch) block; suggest delayed assignments (<=).
                                " Since version 4.032 (04/2020) verilator linter messages also contain the column number,
                                " and look like:
                                " %Error: /tmp/test.sv:3:1: syntax error, unexpected endmodule, expecting ';'
                                "
                                " to stay compatible with old versions of the tool, the column number is
                                " optional in the researched pattern
    1              0.000002     let l:pattern = '^%\(Warning\|Error\)[^:]*:\s*\([^:]\+\):\(\d\+\):\(\d\+\)\?:\? \(.\+\)$'
    1              0.000001     let l:output = []
                            
    2   0.000151   0.000022     for l:match in ale#util#GetMatches(a:lines, l:pattern)
    1              0.000006         let l:item = {   'lnum': str2nr(l:match[3]),   'text': l:match[5],   'type': l:match[1] is# 'Error' ? 'E' : 'W',   'filename': l:match[2],}
                            
    1              0.000001         if !empty(l:match[4])
    1              0.000002             let l:item.col = str2nr(l:match[4])
    1              0.000000         endif
                            
    1              0.000002         call add(l:output, l:item)
    2              0.000001     endfor
                            
    1              0.000001     return l:output

FUNCTION  <SNR>61_StopCurrentJobs()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/engine.vim:478
Called 1 time
Total time:   0.000050
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000003     let l:info = get(g:ale_buffer_info, a:buffer, {})
    1   0.000022   0.000006     call ale#command#StopJobs(a:buffer, 'linter')
                            
                                " Update the active linter list, clearing out anything not running.
    1              0.000001     if a:clear_lint_file_jobs
    1   0.000015   0.000004         call ale#command#StopJobs(a:buffer, 'file_linter')
    1              0.000002         let l:info.active_linter_list = []
                                else
                                    let l:lint_file_map = {}
                            
                                    " Use a previously computed map of `lint_file` values to find
                                    " linters that are used for linting files.
                                    for [l:lint_file, l:linter] in a:linter_slots
                                        if l:lint_file is 1
                                            let l:lint_file_map[l:linter.name] = 1
                                        endif
                                    endfor
                            
                                    " Keep jobs for linting files when we're only linting buffers.
                                    call filter(l:info.active_linter_list, 'get(l:lint_file_map, v:val.name)')
    1              0.000000     endif

FUNCTION  <SNR>61_RemoveProblemsForDisabledLinters()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/engine.vim:506
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
                                " Problems from other sources will be kept.
    1              0.000001     let l:name_map = {}
                            
    2              0.000002     for l:linter in a:linters
    1              0.000002         let l:name_map[l:linter.name] = 1
    2              0.000009     endfor
                            
    1              0.000006     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(v:val, ''from_other_source'') || get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  <SNR>63_FindHistoryItem()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/history.vim:36
Called 2 times
Total time:   0.000025
 Self time:   0.000018

count  total (s)   self (s)
                                " Search backwards to find a matching job ID. IDs might be recycled,
                                " so finding the last one should be good enough.
    2   0.000018   0.000011     for l:obj in reverse(ale#history#Get(a:buffer))
    2              0.000002         if l:obj.job_id == a:job_id
    2              0.000002             return l:obj
                                    endif
                                endfor
                            
                                return {}

FUNCTION  coc#float#check_related()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/float.vim:746
Called 4 times
Total time:   0.000391
 Self time:   0.000137

count  total (s)   self (s)
    4              0.000028   let invalids = []
    4   0.000305   0.000051   let ids = coc#float#get_float_win_list(1)
    4              0.000005   for id in ids
                                let target = getwinvar(id, 'target_winid', 0)
                                if target && index(ids, target) == -1
                                  call add(invalids, id)
                                endif
    4              0.000002   endfor
    4              0.000005   if s:is_vim && !s:popup_list_api
                                let s:popup_list = filter(ids, "index(invalids, v:val) == -1")
    4              0.000002   endif
    4              0.000004   for id in invalids
                                call coc#float#close(id)
    4              0.000002   endfor

FUNCTION  <SNR>62_GatherOutput()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/command.vim:281
Called 7 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    7              0.000022     call add(a:line_list, a:line)

FUNCTION  ale#GetFilenameMappings()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale.vim:284
Called 2 times
Total time:   0.000046
 Self time:   0.000028

count  total (s)   self (s)
    2   0.000026   0.000008     let l:linter_mappings = ale#Var(a:buffer, 'filename_mappings')
                            
    2              0.000003     if type(l:linter_mappings) is v:t_list
                                    return l:linter_mappings
    2              0.000001     endif
                            
    2              0.000002     let l:name = a:name
                            
    2              0.000003     if !has_key(l:linter_mappings, l:name)
                                    " Use * as a default setting for all tools.
    2              0.000002         let l:name = '*'
    2              0.000001     endif
                            
    2              0.000003     return get(l:linter_mappings, l:name, [])

FUNCTION  <SNR>78_check_focus()
    Defined: ~/.config/coc/extensions/node_modules/coc-explorer/autoload/coc_explorer.vim:1
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000004   if !get(a:options, 'focus', v:true)
                                call win_gotoid(a:fallback_winid)
    2              0.000001   endif

FUNCTION  ale#command#RemoveManagedFiles()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/command.vim:83
Called 1 time
Total time:   0.000139
 Self time:   0.000131

count  total (s)   self (s)
    1              0.000003     let l:info = get(s:buffer_data, a:buffer, {})
                            
    1              0.000002     if !empty(l:info) && empty(l:info.jobs)
                                    " We can't delete anything in a sandbox, so wait until we escape from
                                    " it to delete temporary files and directories.
    1   0.000011   0.000003         if ale#util#InSandbox()
                                        return
    1              0.000000         endif
                            
                                    " Delete files with a call akin to a plan `rm` command.
    1              0.000002         for l:filename in l:info.file_list
                                        call delete(l:filename)
    1              0.000001         endfor
                            
                                    " Delete directories like `rm -rf`.
                                    " Directories are handled differently from files, so paths that are
                                    " intended to be single files can be set up for automatic deletion
                                    " without accidentally deleting entire directories.
    2              0.000003         for l:directory in l:info.directory_list
    1              0.000104             call delete(l:directory, 'rf')
    2              0.000002         endfor
                            
    1              0.000004         call remove(s:buffer_data, a:buffer)
    1              0.000000     endif

FUNCTION  ale#job#Start()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/job.vim:221
Called 1 time
Total time:   0.001371
 Self time:   0.001368

count  total (s)   self (s)
    1   0.000009   0.000005     call ale#job#ValidateArguments(a:command, a:options)
                            
    1              0.000003     let l:job_info = copy(a:options)
    1              0.000001     let l:job_options = {}
                            
    1              0.000001     if has('nvim')
    1              0.000001         if has_key(a:options, 'out_cb')
                                        let l:job_options.on_stdout = function('s:NeoVimCallback')
                                        let l:job_info.out_cb_line = ''
    1              0.000000         endif
                            
    1              0.000001         if has_key(a:options, 'err_cb')
    1              0.000003             let l:job_options.on_stderr = function('s:NeoVimCallback')
    1              0.000001             let l:job_info.err_cb_line = ''
    1              0.000000         endif
                            
    1              0.000001         if has_key(a:options, 'exit_cb')
    1              0.000002             let l:job_options.on_exit = function('s:NeoVimCallback')
    1              0.000000         endif
                            
    1              0.001309         let l:job_info.job = jobstart(a:command, l:job_options)
    1              0.000004         let l:job_id = l:job_info.job
                                else
                                    let l:job_options = {   'in_mode': l:job_info.mode,   'out_mode': l:job_info.mode,   'err_mode': l:job_info.mode,}
                            
                                    if has_key(a:options, 'out_cb')
                                        let l:job_options.out_cb = function('s:VimOutputCallback')
                                    else
                                        " prevent buffering of output and excessive polling in case close_cb is set
                                        let l:job_options.out_cb = {->0}
                                    endif
                            
                                    if has_key(a:options, 'err_cb')
                                        let l:job_options.err_cb = function('s:VimErrorCallback')
                                    else
                                        " prevent buffering of output and excessive polling in case close_cb is set
                                        let l:job_options.err_cb = {->0}
                                    endif
                            
                                    if has_key(a:options, 'exit_cb')
                                        " Set a close callback to which simply calls job_status()
                                        " when the channel is closed, which can trigger the exit callback
                                        " earlier on.
                                        let l:job_options.close_cb = function('s:VimCloseCallback')
                                        let l:job_options.exit_cb = function('s:VimExitCallback')
                                    endif
                            
                                    " Use non-blocking writes for Vim versions that support the option.
                                    if has('patch-8.1.350')
                                        let l:job_options.noblock = 1
                                    endif
                            
                                    " Vim 8 will read the stdin from the file's buffer.
                                    let l:job_info.job = job_start(a:command, l:job_options)
                                    let l:job_id = ale#job#ParseVim8ProcessID(string(l:job_info.job))
    1              0.000000     endif
                            
    1              0.000001     if l:job_id > 0
                                    " Store the job in the map for later only if we can get the ID.
    1              0.000004         let s:job_map[l:job_id] = l:job_info
    1              0.000000     endif
                            
    1              0.000002     return l:job_id

FUNCTION  coc#rpc#request()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/rpc.vim:182
Called 3 times
Total time:   0.003404
 Self time:   0.000048

count  total (s)   self (s)
    3   0.000049   0.000019   if !coc#rpc#ready()
                                return ''
    3              0.000001   endif
    3   0.003349   0.000023   return s:client['request'](a:method, a:args)

FUNCTION  coc#util#bufsize()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/util.vim:497
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000002   if bufnr('%') == a:bufnr
    1              0.000002     return line2byte(line("$") + 1)
                              endif
                              let bufname = bufname(a:bufnr)
                              if !getbufvar(a:bufnr, '&modified') && filereadable(bufname)
                                return getfsize(bufname)
                              endif
                              return strlen(join(getbufline(a:bufnr, 1, '$'), '\n'))

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: /usr/share/nvim/runtime/ftplugin.vim:15
Called 1 time
Total time:   0.000969
 Self time:   0.000882

count  total (s)   self (s)
    1              0.000005     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    1              0.000001     endif
                            
    1              0.000004     let s = expand("<amatch>")
    1              0.000001     if s != ""
    1              0.000006       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    1              0.000000       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    2              0.000006       for name in split(s, '\.')
                                    " Load Lua ftplugins after Vim ftplugins _per directory_
                                    " TODO(clason): use nvim__get_runtime when supports globs and modeline
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
    1   0.000931   0.000843         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
    2              0.000002       endfor
    1              0.000001     endif

FUNCTION  ale#events#ReadOrEnterEvent()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/events.vim:51
Called 12 times
Total time:   0.000338
 Self time:   0.000338

count  total (s)   self (s)
                                " Apply pattern options if the variable is set.
   12              0.000070     if get(g:, 'ale_pattern_options_enabled', 1)&& !empty(get(g:, 'ale_pattern_options'))
                                    call ale#pattern_options#SetOptions(a:buffer)
   12              0.000009     endif
                            
                                " When entering a buffer, we are no longer quitting it.
   12              0.000055     call setbufvar(a:buffer, 'ale_quitting', 0)
   12              0.000055     let l:filetype = getbufvar(a:buffer, '&filetype')
   12              0.000033     call setbufvar(a:buffer, 'ale_original_filetype', l:filetype)
                            
                                " If the file changed outside of Vim, check it on BufEnter,BufRead
   12              0.000019     if getbufvar(a:buffer, 'ale_file_changed')
                                    call ale#events#LintOnEnter(a:buffer)
   12              0.000004     endif

FUNCTION  coc_explorer#util#execute_commands()
    Defined: ~/.config/coc/extensions/node_modules/coc-explorer/autoload/coc_explorer/util.vim:2
Called 2 times
Total time:   0.000689
 Self time:   0.000689

count  total (s)   self (s)
    2              0.000008   if &filetype == 'coc-explorer'
  324              0.000149     for cmd in a:cmds
  322              0.000412       execute cmd
  324              0.000082     endfor
    2              0.000001   endif

FUNCTION  provider#python3#Call()
    Defined: /usr/share/nvim/runtime/autoload/provider/python3.vim:5
Called 8 times
Total time:   0.007641
 Self time:   0.007641

count  total (s)   self (s)
    8              0.007626   return v:lua.vim.provider.python.call(a:method, a:args)

FUNCTION  ale#history#RememberOutput()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/history.vim:58
Called 1 time
Total time:   0.000016
 Self time:   0.000006

count  total (s)   self (s)
    1   0.000014   0.000004     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
    1              0.000001     let l:obj.output = a:output

FUNCTION  ale#ShouldDoNothing()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale.vim:29
Called 197 times
Total time:   0.023249
 Self time:   0.015172

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
  197              0.001516     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
  197              0.000071     endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
  197              0.000627     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
  197              0.000062     endif
                            
  197              0.001013     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
  197              0.000220     if l:filetype is# ''
                                    return 1
  197              0.000061     endif
                            
                                " Do nothing for diff buffers.
  197              0.000446     if getbufvar(a:buffer, '&diff')
                                    return 1
  197              0.000059     endif
                            
                                " Do nothing for blacklisted files.
  197              0.001067     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
  197              0.000059     endif
                            
                                " Do nothing if running from command mode.
  197              0.000676     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
  197              0.000058     endif
                            
  197              0.000798     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
  197              0.000195     if l:filename is# '.'
                                    return 1
  197              0.000062     endif
                            
                                " Don't start linting and so on when an operator is pending.
  197   0.002209   0.001123     if ale#util#Mode(1) is# 'no'
                                    return 1
  197              0.000066     endif
                            
                                " Do nothing if running in the sandbox.
  197   0.006198   0.000903     if ale#util#InSandbox()
                                    return 1
  197              0.000071     endif
                            
                                " Do nothing if the file is too large.
  197   0.002840   0.001144     if ale#FileTooLarge(a:buffer)
                                    return 1
  197              0.000066     endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
  197              0.001270     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
  197              0.000070     endif
                            
  197              0.000110     return 0

FUNCTION  coc#util#get_editoroption()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/util.vim:384
Called 3 times
Total time:   0.001434
 Self time:   0.000140

count  total (s)   self (s)
    3              0.000036   let info = get(getwininfo(a:winid), 0, v:null)
    3   0.000082   0.000024   if empty(info) || coc#window#is_float(a:winid)
                                return v:null
    3              0.000001   endif
    3              0.000006   let bufnr = info['bufnr']
    3              0.000009   let buftype = getbufvar(bufnr, '&buftype')
                              " avoid window for other purpose.
    3              0.000005   if buftype !=# '' && buftype !=# 'acwrite'
    2              0.000002     return v:null
    1              0.000001   endif
    1              0.000003   let tabSize = getbufvar(bufnr, '&shiftwidth')
    1              0.000001   if tabSize == 0
                                let tabSize = getbufvar(bufnr, '&tabstop')
    1              0.000001   endif
    1   0.001271   0.000035   return { 'bufnr': bufnr, 'winid': a:winid, 'tabpageid': coc#util#tabnr_id(info['tabnr']), 'winnr': winnr(), 'visibleRanges': s:visible_ranges(a:winid), 'tabSize': tabSize, 'insertSpaces': getbufvar(bufnr, '&expandtab') ? v:true : v:false }

FUNCTION  <SNR>62_ExitCallback()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/command.vim:285
Called 1 time
Total time:   0.001438
 Self time:   0.000066

count  total (s)   self (s)
    1              0.000002     if !has_key(s:buffer_data, a:buffer)
                                    return
    1              0.000000     endif
                            
    1              0.000002     let l:jobs = s:buffer_data[a:buffer].jobs
                            
    1              0.000002     if !has_key(l:jobs, a:data.job_id)
                                    return
    1              0.000000     endif
                            
    1              0.000003     let l:job_type = remove(l:jobs, a:data.job_id)
                            
    1              0.000001     if g:ale_history_enabled
    1   0.000030   0.000006         call ale#history#SetExitCode(a:buffer, a:data.job_id, a:data.exit_code)
                            
                                    " Log the output of the command for ALEInfo if we should.
    1              0.000002         if g:ale_history_log_output && a:data.log_output is 1
    1   0.000022   0.000007             call ale#history#RememberOutput(   a:buffer,   a:data.job_id,   a:line_list[:])
    1              0.000000         endif
    1              0.000000     endif
                            
                                " If the callback starts any new jobs, use the same job type for them.
    1              0.000002     call setbufvar(a:buffer, 'ale_job_type', l:job_type)
    1   0.001325   0.000011     let l:value = a:Callback(a:buffer, a:line_list, {   'exit_code': a:data.exit_code,   'temporary_file': a:data.temporary_file,})
                            
    1              0.000002     let l:result = a:data.result
    1              0.000001     let l:result.value = l:value
                            
                                " Set the default cwd for this buffer in this call stack.
    1   0.000022   0.000009     call ale#command#SetCwd(a:buffer, l:result.cwd)
                            
    1              0.000000     try
    1              0.000003         if get(l:result, 'result_callback', v:null) isnot v:null
                                        call call(l:result.result_callback, [l:value])
    1              0.000000         endif
    1              0.000001     finally
    1   0.000008   0.000004         call ale#command#ResetCwd(a:buffer)
    1              0.000001     endtry

FUNCTION  <SNR>14_Autocmd()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/plugin/coc.vim:259
Called 293 times
Total time:   0.027010
 Self time:   0.003704

count  total (s)   self (s)
  293              0.001309   if !get(g:, 'coc_workspace_initialized', 0)
                                return
  293              0.000194   endif
  293   0.024799   0.001493   call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  coc#util#editor_infos()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/util.vim:418
Called 4 times
Total time:   0.000660
 Self time:   0.000488

count  total (s)   self (s)
    4              0.000009   let result = []
   13              0.000054   for info in getwininfo()
    9   0.000178   0.000048     if !coc#window#is_float(info['winid'])
    9              0.000013       let bufnr = info['bufnr']
    9              0.000031       let buftype = getbufvar(bufnr, '&buftype')
    9              0.000013       if buftype !=# '' && buftype !=# 'acwrite'
                                    continue
    9              0.000003       endif
    9              0.000016       let bufname = bufname(bufnr)
    9   0.000265   0.000223       call add(result, { 'winid': info['winid'], 'bufnr': bufnr, 'tabid': coc#util#tabnr_id(info['tabnr']), 'fullpath': empty(bufname) ? '' : fnamemodify(bufname, ':p'), })
    9              0.000005     endif
   13              0.000012   endfor
    4              0.000004   return result

FUNCTION  ale#history#SetExitCode()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/history.vim:49
Called 1 time
Total time:   0.000025
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000021   0.000006     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                " If we find a match, then set the code and status.
    1              0.000002     let l:obj.exit_code = a:exit_code
    1              0.000001     let l:obj.status = 'finished'

FUNCTION  ale#util#Writefile()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/util.vim:432
Called 1 time
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    1              0.000005     let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'   ? map(copy(a:lines), 'substitute(v:val, ''\r*$'', ''\r'', '''')')   : a:lines
                            
                                " Set binary flag if buffer doesn't have eol and nofixeol to avoid appending newline
    1              0.000004     let l:flags = !getbufvar(a:buffer, '&eol') && exists('+fixeol') && !&fixeol ? 'bS' : 'S'
                            
    1              0.000034     call writefile(l:corrected_lines, a:filename, l:flags) " no-custom-checks

FUNCTION  ale#cursor#EchoCursorWarning()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/cursor.vim:74
Called 182 times
Total time:   0.048700
 Self time:   0.012600

count  total (s)   self (s)
  182              0.002781     let l:buffer = bufnr('')
                            
  182              0.000721     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
  182              0.000174     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
  182              0.000827     if mode(1) isnot# 'n'
                                    return
  182              0.000066     endif
                            
  182   0.023227   0.001126     if ale#ShouldDoNothing(l:buffer)
                                    return
  182              0.000055     endif
                            
  182   0.014301   0.001291     let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
  182              0.000176     if g:ale_echo_cursor
  182              0.000244         if !empty(l:loc)
    1   0.000013   0.000005             let l:format = ale#Var(l:buffer, 'echo_msg_format')
    1   0.000057   0.000007             let l:msg = ale#GetLocItemMessage(l:loc, l:format)
    1   0.000940   0.000008             call ale#cursor#TruncatedEcho(l:msg)
    1              0.000002             let l:info.echoed = 1
  181              0.000314         elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
                                        "
                                        " no-custom-checks
    1              0.000007             echo
    1              0.000002             let l:info.echoed = 0
  182              0.000077         endif
  182              0.000074     endif
                            
  182              0.000185     if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
  182              0.000067     endif

FUNCTION  <SNR>71_SetListsImpl()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/list.vim:100
Called 1 time
Total time:   0.000262
 Self time:   0.000104

count  total (s)   self (s)
    1              0.000006     let l:title = expand('#' . a:buffer . ':p')
                            
    1              0.000001     if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
    1              0.000001     elseif g:ale_set_loclist
                                    " If windows support is off, win_findbuf() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
    1   0.000011   0.000005         let l:ids = s:WinFindBuf(a:buffer)
                            
    1   0.000013   0.000005         let l:loclist = s:Deduplicate(a:loclist)
                            
    2              0.000002         for l:id in l:ids
    1              0.000002             if has('nvim')
    1   0.000098   0.000011                 call setloclist(l:id, s:FixList(a:buffer, l:loclist), ' ', l:title)
                                        else
                                            call setloclist(l:id, s:FixList(a:buffer, l:loclist))
                                            call setloclist(l:id, [], 'r', {'title': l:title})
    1              0.000000             endif
    2              0.000001         endfor
    1              0.000000     endif
                            
                                " Save the current view before opening/closing any window
    1              0.000004     call setbufvar(a:buffer, 'ale_winview', winsaveview())
                            
                                " Open a window to show the problems if we need to.
                                "
                                " ShouldOpen() checks if the current buffer has enough problems to be
                                " opened.
    1   0.000022   0.000007     if s:ShouldOpen(a:buffer, len(a:loclist))
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                            
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert rightbelow '
                                    endif
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    " Return to original mode when applicable
                                    if mode() != l:mode
                                        if l:mode is? 'v' || l:mode is# "\<c-v>"
                                            " Reset our last visual selection
                                            normal! gv
                                        elseif l:mode is? 's' || l:mode is# "\<c-s>"
                                            " Reset our last character selection
                                            normal! "\<c-g>"
                                        endif
                                    endif
                            
                                    call s:RestoreViewIfNeeded(a:buffer)
    1              0.000000     endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
    1   0.000011   0.000004     if !ale#engine#IsCheckingBuffer(a:buffer)
    1   0.000041   0.000005         call s:CloseWindowIfNeeded(a:buffer)
    1              0.000000     endif

FUNCTION  coc#window#is_float()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/window.vim:101
Called 12 times
Total time:   0.000188
 Self time:   0.000188

count  total (s)   self (s)
   12              0.000017   if s:is_vim
                                try
                                  return !empty(popup_getpos(a:winid))
                                catch /^Vim\%((\a\+)\)\=:E993/
                                  return 0
                                endtry
   12              0.000005   else
   12              0.000049     let config = nvim_win_get_config(a:winid)
   12              0.000041     return !empty(config) && !empty(get(config, 'relative', ''))
                              endif

FUNCTION  ale#events#QuitEvent()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/events.vim:14
Called 3 times
Total time:   0.000061
 Self time:   0.000039

count  total (s)   self (s)
                                " Remember when ALE is quitting for BufWrite, etc.
    3   0.000053   0.000031     call setbufvar(a:buffer, 'ale_quitting', ale#events#ClockMilliseconds())

FUNCTION  ale#engine#InitBufferInfo()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/engine.vim:82
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000002     if !has_key(g:ale_buffer_info, a:buffer)
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
    1              0.000004         let g:ale_buffer_info[a:buffer] = {   'active_linter_list': [],   'active_other_sources_list': [],   'loclist': [],}
                            
    1              0.000001         return 1
                                endif
                            
                                return 0

FUNCTION  ale#FileTooLarge()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale.vim:21
Called 197 times
Total time:   0.001696
 Self time:   0.001696

count  total (s)   self (s)
  197              0.000831     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
  197              0.000586     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  ale#engine#MarkLinterInactive()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/engine.vim:43
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000005     call filter(a:info.active_linter_list, 'v:val.name isnot# a:linter_name')

FUNCTION  <SNR>62_FormatFilename()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/command.vim:156
Called 2 times
Total time:   0.000043
 Self time:   0.000025

count  total (s)   self (s)
    2              0.000003     let l:filename = a:filename
                            
    2              0.000002     if !empty(a:mappings)
                                    let l:filename = ale#filename_mapping#Map(l:filename, a:mappings)
    2              0.000001     endif
                            
    2              0.000002     if !empty(a:modifiers)
    1              0.000002         let l:filename = fnamemodify(l:filename, a:modifiers)
    2              0.000001     endif
                            
    2   0.000026   0.000008     return ale#Escape(l:filename)

FUNCTION  ale#engine#IsCheckingBuffer()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/engine.vim:101
Called 3 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    3              0.000007     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
    3              0.000011     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  ale#job#ValidateArguments()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/job.vim:144
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002     if a:options.mode isnot# 'nl' && a:options.mode isnot# 'raw'
                                    throw 'Invalid mode: ' . a:options.mode
    1              0.000000     endif

FUNCTION  ale#engine#MarkLinterActive()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/engine.vim:28
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000001     let l:found = 0
                            
    1              0.000002     for l:other_linter in a:info.active_linter_list
                                    if l:other_linter.name is# a:linter.name
                                        let l:found = 1
                                        break
                                    endif
    1              0.000001     endfor
                            
    1              0.000001     if !l:found
    1              0.000002         call add(a:info.active_linter_list, a:linter)
    1              0.000000     endif

FUNCTION  coc_explorer#util#close_win_by_bufnr()
    Defined: ~/.config/coc/extensions/node_modules/coc-explorer/autoload/coc_explorer/util.vim:69
Called 2 times
Total time:   0.000898
 Self time:   0.000233

count  total (s)   self (s)
    4              0.000007     for bufnr in a:000
    2              0.000002       try
    2              0.000004         let winid = bufwinid(bufnr)
    2              0.000003         if winid >= 0
    2   0.000867   0.000202           call nvim_win_close(winid, v:true)
    2              0.000001         endif
                                  catch
    2              0.000001       endtry
    4              0.000002     endfor

FUNCTION  ale#command#ResetCwd()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/command.vim:39
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000002     if has_key(s:buffer_data, a:buffer)
    1              0.000002         let s:buffer_data[a:buffer].cwd = v:null
    1              0.000000     endif

FUNCTION  ale#Var()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale.vim:194
Called 226 times
Total time:   0.002336
 Self time:   0.002336

count  total (s)   self (s)
  226              0.000460     let l:full_name = 'ale_' . a:variable_name
  226              0.000941     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
  226              0.000696     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  ale#command#FormatCommand()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/command.vim:192
Called 1 time
Total time:   0.000328
 Self time:   0.000107

count  total (s)   self (s)
    1              0.000001     let l:temporary_file = ''
    1              0.000001     let l:command = a:command
                            
    1              0.000001     if !empty(a:cwd)
                                    let l:command = ale#command#CdString(a:cwd) . l:command
    1              0.000000     endif
                            
                                " First replace all uses of %%, used for literal percent characters,
                                " with an ugly string.
    1              0.000004     let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
                            
                                " Replace %e with the escaped executable, if available.
    1              0.000013     if !empty(a:executable) && l:command =~# '%e'
                                    let l:command = substitute(l:command, '%e', '\=ale#Escape(a:executable)', 'g')
    1              0.000000     endif
                            
                                " Replace all %s occurrences in the string with the name of the current
                                " file.
    1              0.000001     if l:command =~# '%s'
    1              0.000010         let l:filename = fnamemodify(bufname(a:buffer), ':p')
    1   0.000049   0.000023         let l:command = substitute(   l:command,   s:path_format_regex,   '\=s:FormatFilename(l:filename, a:mappings, submatch(1))',   'g')
    1              0.000000     endif
                            
    1              0.000002     if a:input isnot v:false && l:command =~# '%t'
                                    " Create a temporary filename, <temp_dir>/<original_basename>
                                    " The file itself will not be created by this function.
    1   0.000038   0.000006         let l:temporary_file = s:TemporaryFilename(a:buffer)
    1   0.000029   0.000012         let l:command = substitute(   l:command,   '\v\%t(%(:h|:t|:r|:e)*)',   '\=s:FormatFilename(l:temporary_file, a:mappings, submatch(1))',   'g')
    1              0.000000     endif
                            
                                " Finish formatting so %% becomes %.
    1              0.000007     let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
                            
    1              0.000001     if a:pipe_file_if_needed && empty(l:temporary_file)
                                    " If we are to send the Vim buffer to a command, we'll do it
                                    " in the shell. We'll write out the file to a temporary file,
                                    " and then read it back in, in the shell.
                                    let l:temporary_file = s:TemporaryFilename(a:buffer)
                                    let l:command = l:command . ' < ' . ale#Escape(l:temporary_file)
    1              0.000000     endif
                            
    1   0.000155   0.000009     let l:file_created = ale#command#CreateTempFile(   a:buffer,   l:temporary_file,   a:input,)
                            
    1              0.000002     return [l:temporary_file, l:command, l:file_created]

FUNCTION  <SNR>2_LoadIndent()
    Defined: /usr/share/nvim/runtime/indent.vim:14
Called 1 time
Total time:   0.000284
 Self time:   0.000247

count  total (s)   self (s)
    1              0.000002     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    1              0.000000     endif
    1              0.000002     let s = expand("<amatch>")
    1              0.000001     if s != ""
    1              0.000001       if exists("b:did_indent")
                            	unlet b:did_indent
    1              0.000000       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    2              0.000004       for name in split(s, '\.')
                                    " XXX: "[.]" in the pattern makes it a wildcard on Windows
    1   0.000266   0.000229         exe $'runtime! indent/{name}[.]{{vim,lua}}'
    2              0.000001       endfor
    1              0.000000     endif

FUNCTION  <SNR>52_GetAliasedFiletype()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/linter.vim:301
Called 10 times
Total time:   0.000408
 Self time:   0.000408

count  total (s)   self (s)
   10              0.000050     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List or String.
   10              0.000056     if type(l:buffer_aliases) is v:t_list|| type(l:buffer_aliases) is v:t_string
                                    return l:buffer_aliases
   10              0.000008     endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
   40              0.000074     for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
   30              0.000059         if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
   30              0.000011         endif
   40              0.000019     endfor
                            
   10              0.000011     return a:original_filetype

FUNCTION  ale#command#Run()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/command.vim:333
Called 1 time
Total time:   0.001912
 Self time:   0.000139

count  total (s)   self (s)
    1              0.000002     let l:options = get(a:000, 0, {})
                            
    1              0.000001     if len(a:000) > 1
                                    throw 'Too many arguments!'
    1              0.000000     endif
                            
    1              0.000002     let l:output_stream = get(l:options, 'output_stream', 'stdout')
    1              0.000001     let l:line_list = []
    1              0.000002     let l:cwd = get(l:options, 'cwd', v:null)
                            
    1              0.000001     if l:cwd is v:null
                                    " Default the working directory to whatever it was for the last
                                    " command run in the chain.
    1              0.000003         let l:cwd = get(get(s:buffer_data, a:buffer, {}), 'cwd', v:null)
    1              0.000000     endif
                            
    1   0.000339   0.000012     let [l:temporary_file, l:command, l:file_created] = ale#command#FormatCommand(   a:buffer,   get(l:options, 'executable', ''),   a:command,   get(l:options, 'read_buffer', 0),   get(l:options, 'input', v:null),   l:cwd,   get(l:options, 'filename_mappings', []),)
    1   0.000060   0.000009     let l:command = ale#job#PrepareCommand(a:buffer, l:command)
    1              0.000008     let l:job_options = {   'exit_cb': {job_id, exit_code -> s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )},   'mode': 'nl',}
                            
    1              0.000001     if l:output_stream is# 'stdout'
                                    let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
    1              0.000001     elseif l:output_stream is# 'stderr'
    1              0.000004         let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
                                elseif l:output_stream is# 'both'
                                    let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
    1              0.000000     endif
                            
    1              0.000001     let l:status = 'failed'
                            
    1              0.000002     if get(g:, 'ale_run_synchronously') == 1
                                    if get(g:, 'ale_emulate_job_failure') == 1
                                        let l:job_id = 0
                                    else
                                        " Generate a fake job ID for tests.
                                        let s:fake_job_id = get(s:, 'fake_job_id', 0) + 1
                                        let l:job_id = s:fake_job_id
                                    endif
    1              0.000002     elseif has('win32')
                                    let l:job_id = ale#job#StartWithCmd(l:command, l:job_options)
    1              0.000000     else
    1   0.001379   0.000008         let l:job_id = ale#job#Start(l:command, l:job_options)
    1              0.000001     endif
                            
    1              0.000001     if l:job_id
    1              0.000001         let l:status = 'started'
    1              0.000003         let l:job_type = getbufvar(a:buffer, 'ale_job_type', 'all')
                            
    1   0.000017   0.000012         call ale#command#InitData(a:buffer)
    1              0.000003         let s:buffer_data[a:buffer].jobs[l:job_id] = l:job_type
    1              0.000000     endif
                            
    1              0.000001     if g:ale_history_enabled
    1   0.000023   0.000006         call ale#history#Add(a:buffer, l:status, l:job_id, l:command)
    1              0.000000     endif
                            
    1              0.000001     if !l:job_id
                                    return 0
    1              0.000000     endif
                            
                                " We'll return this Dictionary. A `result_callback` can be assigned to it
                                " later for capturing the result of a:Callback.
                                "
                                " The `_deferred_job_id` is used for both checking the type of object, and
                                " for checking the job ID and status.
                                "
                                " The cwd is kept and used as the default value for the next command in
                                " the chain.
                                "
                                " The original command here is used in tests.
    1              0.000004     let l:result = {   '_deferred_job_id': l:job_id,   'executable': get(l:options, 'executable', ''),   'cwd': l:cwd,   'command': a:command,}
                            
    1              0.000002     if get(g:, 'ale_run_synchronously') == 1 && l:job_id
                                    if !exists('g:ale_run_synchronously_callbacks')
                                        let g:ale_run_synchronously_callbacks = []
                                    endif
                            
                                    if get(g:, 'ale_run_synchronously_emulate_commands', 0)
                                        call add(   g:ale_run_synchronously_callbacks,   {exit_code, output -> [       extend(l:line_list, output),       l:job_options.exit_cb(l:job_id, exit_code),   ]})
                                    else
                                        " Run a command synchronously if this test option is set.
                                        call extend(l:line_list, systemlist(   type(l:command) is v:t_list       ? join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])       : l:command))
                            
                                        " Don't capture output when the callbacks aren't set.
                                        if !has_key(l:job_options, 'out_cb')&& !has_key(l:job_options, 'err_cb')
                                            let l:line_list = []
                                        endif
                            
                                        call add(   g:ale_run_synchronously_callbacks,   {-> l:job_options.exit_cb(l:job_id, v:shell_error)})
                                    endif
    1              0.000000     endif
                            
    1              0.000001     return l:result

FUNCTION  ale#events#ClockMilliseconds()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/events.vim:10
Called 3 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    3              0.000019     return float2nr(reltimefloat(reltime()) * 1000)

FUNCTION  ale#events#FileTypeEvent()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/events.vim:69
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
                                " The old filetype will be set to an empty string by the BuFEnter event,
                                " and not linting when the old filetype hasn't been set yet prevents
                                " buffers being checked when you enter them when linting on enter is off.
    1              0.000004     let l:old_filetype = getbufvar(a:buffer, 'ale_original_filetype', v:null)
                            
    1              0.000003     if l:old_filetype isnot v:null&& !empty(a:new_filetype)&& a:new_filetype isnot# l:old_filetype
                                    " Remember what the new filetype is.
                                    call setbufvar(a:buffer, 'ale_original_filetype', a:new_filetype)
                            
                                    if g:ale_lint_on_filetype_changed
                                        call ale#Queue(300, 'lint_file', a:buffer)
                                    endif
    1              0.000000     endif

FUNCTION  <SNR>26_Highlight_Matching_Pair()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:44
Called 233 times
Total time:   0.017558
 Self time:   0.015606

count  total (s)   self (s)
  233              0.000737   if !exists("w:matchparen_ids")
    3              0.000004     let w:matchparen_ids = []
  233              0.000085   endif
                              " Remove any previous match.
  233   0.002823   0.000870   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  233              0.000776   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
  233              0.000070   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  233              0.000390   let c_lnum = line('.')
  233              0.000343   let c_col = col('.')
  233              0.000183   let before = 0
                            
  233              0.000549   let text = getline(c_lnum)
  233              0.002908   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  233              0.000326   if empty(matches)
                                let [c_before, c] = ['', '']
  233              0.000084   else
  233              0.000696     let [c_before, c] = matches[1:2]
  233              0.000092   endif
  233              0.002475   let plist = split(&matchpairs, '.\zs[:,]')
  233              0.000528   let i = index(plist, c)
  233              0.000172   if i < 0
                                " not found, in Insert mode try character before the cursor
  230              0.000507     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
  230              0.000098     endif
  230              0.000135     if i < 0
                                  " not found, nothing to do
  230              0.000148       return
                                endif
    3              0.000001   endif
                            
                              " Figure out the arguments for searchpairpos().
    3              0.000003   if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
    3              0.000001   else
    3              0.000003     let s_flags = 'nbW'
    3              0.000003     let c2 = c
    3              0.000004     let c = plist[i - 1]
    3              0.000001   endif
    3              0.000003   if c == '['
                                let c = '\['
                                let c2 = '\]'
    3              0.000001   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    3              0.000002   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
    3              0.000001   endif
                            
    3              0.000045   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
    3              0.000001   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
    3              0.000008     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
    3              0.000001     try
    3              0.000065       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
    3              0.000001     endtry
    3              0.000001   endif
                            
                              " Limit the search to lines visible in the window.
    3              0.000006   let stoplinebottom = line('w$')
    3              0.000005   let stoplinetop = line('w0')
    3              0.000003   if i % 2 == 0
                                let stopline = stoplinebottom
    3              0.000001   else
    3              0.000005     let stopline = stoplinetop
    3              0.000001   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    3              0.000005   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    3              0.000001   else
    3              0.000009     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    3              0.000001   endif
    3              0.000001   try
    3              0.000132     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
    3              0.000001   endtry
                            
    3              0.000002   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
    3              0.000001   endif
                            
                              " If a match is found setup match highlighting.
    3              0.000005   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    3              0.000003     if s:has_matchaddpos
    3              0.000023       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                  call add(w:matchparen_ids, 3)
    3              0.000001     endif
    3              0.000004     let w:paren_hl_on = 1
    3              0.000001   endif

FUNCTION  ale#command#IsDeferred()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/command.vim:471
Called 4 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    4              0.000009     return type(a:value) is v:t_dict && has_key(a:value, '_deferred_job_id')

FUNCTION  <SNR>71_ShouldOpen()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/list.vim:41
Called 1 time
Total time:   0.000016
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000011   0.000003     let l:val = ale#Var(a:buffer, 'open_list')
    1              0.000002     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
    1              0.000002     return l:val > 0 ? a:loclist_len >= l:val : l:val is# 'on_save' && l:saved

FUNCTION  coc#highlight#ranges()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/highlight.vim:223
Called 472 times
Total time:   0.280796
 Self time:   0.038333

count  total (s)   self (s)
  472              0.000868   let bufnr = a:bufnr == 0 ? bufnr('%') : a:bufnr
  472              0.000986   if !bufloaded(bufnr) || !exists('*getbufline')
                                return
  472              0.000131   endif
  472              0.000806   let opts = get(a:, 1, {})
  472              0.001041   let synmaxcol = getbufvar(a:bufnr, '&synmaxcol', 1000)
  472              0.000351   if synmaxcol == 0
                                let synmaxcol = 1000
  472              0.000123   endif
  472              0.000788   let synmaxcol = min([synmaxcol, 1000])
  472   0.003007   0.001941   let srcId = coc#highlight#create_namespace(a:key)
  944              0.000728   for range in a:ranges
  472              0.000566     let start = range['start']
  472              0.000481     let end = range['end']
  944              0.001319     for lnum in range(start['line'] + 1, end['line'] + 1)
  472              0.000812       let arr = getbufline(bufnr, lnum)
  472              0.000809       let line = empty(arr) ? '' : arr[0]
  472              0.000456       if empty(line)
                                    continue
  472              0.000123       endif
  472              0.000769       if start['character'] > synmaxcol || end['character'] > synmaxcol
                                    continue
  472              0.000162       endif
  472   0.111446   0.002339       let colStart = lnum == start['line'] + 1 ? coc#string#byte_index(line, start['character']) : 0
  472   0.125395   0.003680       let colEnd = lnum == end['line'] + 1 ? coc#string#byte_index(line, end['character']) : strlen(line)
  472              0.000424       if colStart == colEnd
                                    continue
  472              0.000119       endif
  472   0.014634   0.004060       call coc#highlight#add_highlight(bufnr, srcId, a:hlGroup, lnum - 1, colStart, colEnd, opts)
  944              0.000530     endfor
  944              0.000380   endfor

FUNCTION  <SNR>38_SynSet()
    Defined: /usr/share/nvim/runtime/syntax/synload.vim:27
Called 1 time
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    1              0.000006   syn clear
    1              0.000008   if exists("b:current_syntax")
                                unlet b:current_syntax
    1              0.000001   endif
                            
    1              0.000005   0verbose let s = expand("<amatch>")
    1              0.000002   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    1              0.000001   elseif s == "OFF"
                                let s = ""
    1              0.000000   endif
                            
    1              0.000001   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
                                for name in split(s, '\.')
                                  if !empty(name)
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
                                    exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
                                  endif
                                endfor
    1              0.000000   endif

FUNCTION  <SNR>62_TemporaryFilename()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/command.vim:132
Called 1 time
Total time:   0.000033
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000002     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
    1              0.000001     if empty(l:filename)
                                    " If the buffer's filename is empty, create a dummy filename.
                                    let l:ft = getbufvar(a:buffer, '&filetype')
                                    let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
    1              0.000000     endif
                            
                                " Create a temporary filename, <temp_dir>/<original_basename>
                                " The file itself will not be created by this function.
    1   0.000025   0.000008     return ale#util#Tempname() . (has('win32') ? '\' : '/') . l:filename

FUNCTION  coc_explorer#tab#current_id()
    Defined: ~/.config/coc/extensions/node_modules/coc-explorer/autoload/coc_explorer/tab.vim:11
Called 16 times
Total time:   0.000328
 Self time:   0.000159

count  total (s)   self (s)
   16   0.000283   0.000115   call coc_explorer#tab#init_id()
   16              0.000023   return t:coc_explorer_tab_id

FUNCTION  <SNR>61_RunLinter()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/engine.vim:608
Called 1 time
Total time:   0.002120
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000001     if !empty(a:linter.lsp)
                                    return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
    1              0.000000     else
    1   0.000009   0.000005         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
    1   0.002106   0.000009         return s:RunIfExecutable(a:buffer, a:linter, a:lint_file, l:executable)
                                endif
                            
                                return 0

FUNCTION  ale#Queue()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale.vim:137
Called 14 times
Total time:   0.004918
 Self time:   0.000508

count  total (s)   self (s)
   14              0.000017     if a:0 > 2
                                    throw 'too many arguments!'
   14              0.000007     endif
                            
   14              0.000030     let l:buffer = get(a:000, 1, v:null)
                            
   14              0.000031     if l:buffer is v:null
   11              0.000017         let l:buffer = bufnr('')
   14              0.000005     endif
                            
   14              0.000022     if type(l:buffer) isnot v:t_number
                                    throw 'buffer_number must be a Number'
   14              0.000004     endif
                            
   14   0.001145   0.000076     if ale#ShouldDoNothing(l:buffer)
                                    return
   14              0.000003     endif
                            
                                " Default linting_flag to ''
   14              0.000027     let l:should_lint_file = get(a:000, 0) is# 'lint_file'
                            
   14              0.000013     if s:lint_timer != -1
   11              0.000023         call timer_stop(s:lint_timer)
   11              0.000010         let s:lint_timer = -1
   14              0.000005     endif
                            
   14              0.000010     if a:delay > 0
   11              0.000068         let s:lint_timer = timer_start(   a:delay,   function('s:Lint', [l:buffer, l:should_lint_file]))
    3              0.000001     else
    3   0.003359   0.000019         call s:Lint(l:buffer, l:should_lint_file, 0)
   14              0.000005     endif

FUNCTION  ale#engine#IsExecutable()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/engine.vim:53
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000001     if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
    1              0.000000     endif
                            
                                " Check for a cached executable() check.
    1              0.000003     let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
    1              0.000001     if l:result isnot v:null
    1              0.000001         return l:result
                                endif
                            
                                " Check if the file is executable, and convert -1 to 1.
                                let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
                                if l:result || get(g:, 'ale_cache_executable_check_failures', 0)
                                    let s:executable_cache_map[a:executable] = l:result
                                endif
                            
                                if g:ale_history_enabled
                                    call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
                                endif
                            
                                return l:result

FUNCTION  ale#Escape()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale.vim:233
Called 2 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    2              0.000005     if fnamemodify(&shell, ':t') is? 'cmd.exe'
                                    " If the string contains spaces, it will be surrounded by quotes.
                                    " Otherwise, special characters will be escaped with carets (^).
                                    return substitute(   a:str =~# ' '       ?  '"' .  substitute(a:str, '"', '""', 'g') . '"'       : substitute(a:str, '\v([&|<>^])', '^\1', 'g'),   '%',   '%%',   'g',)
    2              0.000001     endif
                            
    2              0.000004     return shellescape (a:str)

FUNCTION  coc#float#nvim_win_enter()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/float.vim:877
Called 11 times
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
   11              0.000035   let kind = getwinvar(a:winid, 'kind', '')
   11              0.000017   if kind == 'buttons' || kind == 'close'
                                if empty(maparg('<LeftRelease>', 'n'))
                                  nnoremap <buffer><silent> <LeftRelease> :call coc#float#nvim_float_click()<CR>
                                endif
   11              0.000003   endif

FUNCTION  coc_explorer#tab#init_id()
    Defined: ~/.config/coc/extensions/node_modules/coc-explorer/autoload/coc_explorer/tab.vim:4
Called 16 times
Total time:   0.000168
 Self time:   0.000168

count  total (s)   self (s)
   16              0.000080   if !exists('t:coc_explorer_tab_id')
    1              0.000002     let s:tab_id_max = s:tab_id_max + 1
    1              0.000001     let t:coc_explorer_tab_id = s:tab_id_max
   16              0.000009   endif

FUNCTION  coc#float#get_float_win_list()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/float.vim:567
Called 8 times
Total time:   0.000425
 Self time:   0.000425

count  total (s)   self (s)
    8              0.000013   let res = []
    8              0.000043   let list_all = get(a:, 1, 0)
    8              0.000011   if s:is_vim
                                if s:popup_list_api
                                  return filter(popup_list(), 'popup_getpos(v:val)["visible"]'.(list_all ? '' : '&& getwinvar(v:val, "float", 0)'))
                                endif
                                return filter(s:popup_list, 's:popup_visible(v:val)')
    8              0.000004   else
    8              0.000010     let res = []
   18              0.000046     for i in range(1, winnr('$'))
   10              0.000019       let id = win_getid(i)
   10              0.000068       let config = nvim_win_get_config(id)
   10              0.000030       if empty(config) || empty(config['relative'])
   10              0.000014         continue
                                  endif
                                  " ignore border & button window & others
                                  if list_all == 0 && !getwinvar(id, 'float', 0)
                                    continue
                                  endif
                                  call add(res, id)
    8              0.000007     endfor
    8              0.000008     return res
                              endif
                              return []

FUNCTION  <SNR>71_FixList()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/list.vim:76
Called 1 time
Total time:   0.000087
 Self time:   0.000032

count  total (s)   self (s)
    1   0.000012   0.000004     let l:format = ale#Var(a:buffer, 'loclist_msg_format')
    1              0.000001     let l:new_list = []
                            
    2              0.000002     for l:item in a:list
    1              0.000003         let l:fixed_item = copy(l:item)
                            
    1   0.000053   0.000007         let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
    1              0.000001         if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
    1              0.000000         endif
                            
    1              0.000002         call add(l:new_list, l:fixed_item)
    2              0.000001     endfor
                            
    1              0.000001     return l:new_list

FUNCTION  <SNR>51_ApplyPartialTimer()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/util.vim:447
Called 1 time
Total time:   0.000280
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000003     if has_key(s:partial_timers, a:timer_id)
    1              0.000004         let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
    1   0.000271   0.000009         call call(l:Callback, [a:timer_id] + l:args)
    1              0.000000     endif

FUNCTION  coc#rpc#ready()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/rpc.vim:79
Called 313 times
Total time:   0.002414
 Self time:   0.002414

count  total (s)   self (s)
  313              0.001415   if empty(s:client) || s:client['running'] == 0
                                return 0
  313              0.000109   endif
  313              0.000231   return 1

FUNCTION  <SNR>14_VimLeavePre()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/plugin/coc.vim:311
Called 1 time
Total time:   0.000056
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000001   let g:coc_vim_leaving = 1
    1   0.000046   0.000003   call s:Autocmd('VimLeavePre')
    1              0.000001   if s:is_vim && exists('$COC_NVIM_REMOTE_ADDRESS')
                                " Helps to avoid connection error.
                                call coc#rpc#close_connection()
                                return
    1              0.000000   endif
    1              0.000002   if get(g:, 'coc_node_env', '') ==# 'test'
                                return
    1              0.000000   endif
    1              0.000000   if s:is_vim
                                call timer_start(1, { -> coc#client#kill('coc')})
    1              0.000000   endif

FUNCTION  <SNR>61_AddProblemsFromOtherBuffers()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/engine.vim:522
Called 1 time
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
    1              0.000010     let l:filename = expand('#' . a:buffer . ':p')
    1              0.000001     let l:loclist = []
    1              0.000001     let l:name_map = {}
                            
                                " Build a map of the active linters.
    2              0.000002     for l:linter in a:linters
    1              0.000002         let l:name_map[l:linter.name] = 1
    2              0.000001     endfor
                            
                                " Find the items from other buffers, for the linters that are enabled.
    4              0.000006     for l:info in values(g:ale_buffer_info)
    6              0.000010         for l:item in l:info.loclist
    3              0.000008             if has_key(l:item, 'filename')&& l:item.filename is# l:filename&& has_key(l:name_map, l:item.linter_name)
                                            " Copy the items and set the buffer numbers to this one.
                                            let l:new_item = copy(l:item)
                                            let l:new_item.bufnr = a:buffer
                                            call add(l:loclist, l:new_item)
    3              0.000001             endif
    6              0.000002         endfor
    4              0.000001     endfor
                            
    1              0.000001     if !empty(l:loclist)
                                    call sort(l:loclist, function('ale#util#LocItemCompareWithText'))
                                    call uniq(l:loclist, function('ale#util#LocItemCompareWithText'))
                            
                                    " Set the loclist variable, used by some parts of ALE.
                                    let g:ale_buffer_info[a:buffer].loclist = l:loclist
                                    call ale#engine#SetResults(a:buffer, l:loclist)
    1              0.000000     endif

FUNCTION  <SNR>71_ShouldClose()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/list.vim:50
Called 1 time
Total time:   0.000014
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000009   0.000003     let l:val = ale#Var(a:buffer, 'open_list')
    1              0.000002     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
    1              0.000002     return !((l:val >= 1) || (l:val is# 'on_save' && l:saved))

FUNCTION  ale#linter#GetCommand()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/linter.vim:436
Called 1 time
Total time:   0.000027
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000002     let l:Command = a:linter.command
                            
    1   0.000025   0.000007     return type(l:Command) is v:t_func ? l:Command(a:buffer) : l:Command

FUNCTION  coc#float#on_close()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/float.vim:709
Called 4 times
Total time:   0.000220
 Self time:   0.000049

count  total (s)   self (s)
    4   0.000197   0.000026   let winids = coc#float#get_float_win_list()
    4              0.000004   for winid in winids
                                let target = getwinvar(winid, 'target_winid', -1)
                                if target == a:winid
                                  call coc#float#close(winid)
                                endif
    4              0.000002   endfor

FUNCTION  <SNR>71_CloseWindowIfNeeded()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/list.vim:242
Called 1 time
Total time:   0.000036
 Self time:   0.000015

count  total (s)   self (s)
    1   0.000035   0.000014     if ale#Var(a:buffer, 'keep_list_window_open') || s:ShouldClose(a:buffer)
    1              0.000001         return
                                endif
                            
                                let l:did_close_any_list = 0
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                            let l:did_close_any_list = 1
                                        endif
                                    else
                                        let l:win_ids = s:WinFindBuf(a:buffer)
                            
                                        for l:win_id in l:win_ids
                                            if g:ale_set_loclist && empty(getloclist(l:win_id))
                                                lclose
                                                let l:did_close_any_list = 1
                                            endif
                                        endfor
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry
                            
                                if l:did_close_any_list
                                    call s:RestoreViewIfNeeded(a:buffer)
                                endif

FUNCTION  <SNR>52_GetLinterNames()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/linter.vim:337
Called 10 times
Total time:   0.000212
 Self time:   0.000212

count  total (s)   self (s)
   10              0.000028     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
   10              0.000011     if l:buffer_ale_linters is# 'all'
                                    return 'all'
   10              0.000004     endif
                            
                                " b:ale_linters can be set to a List.
   10              0.000038     if type(l:buffer_ale_linters) is v:t_list
                                    return l:buffer_ale_linters
   10              0.000003     endif
                            
                                " Try to get a buffer-local setting for the filetype
   10              0.000016     if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
   10              0.000003     endif
                            
                                " Try to get a global setting for the filetype
   10              0.000020     if has_key(g:ale_linters, a:original_filetype)
    1              0.000001         return g:ale_linters[a:original_filetype]
    9              0.000003     endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
    9              0.000007     if g:ale_linters_explicit
    9              0.000006         return []
                                endif
                            
                                " Try to get a default setting for the filetype
                                if has_key(s:default_ale_linters, a:original_filetype)
                                    return s:default_ale_linters[a:original_filetype]
                                endif
                            
                                return 'all'

FUNCTION  coc_explorer#resume()
    Defined: ~/.config/coc/extensions/node_modules/coc-explorer/autoload/coc_explorer.vim:67
Called 2 times
Total time:   0.009026
 Self time:   0.000268

count  total (s)   self (s)
    2              0.000010   let fallback_winid = win_getid()
    2              0.000005   if a:position.name ==# 'tab'
                                execute s:tab_cmd(a:position)
                                execute 'silent keepalt buffer'.a:bufnr
                                call s:check_focus(a:options, fallback_winid)
    2              0.000002   elseif a:position.name ==# 'left'
    2              0.000005     wincmd t
    2   0.008850   0.000182     execute 'silent keepalt vertical topleft sb '.a:bufnr
    2   0.000098   0.000016     call coc_explorer#resize(a:bufnr, a:position, a:options)
    2   0.000021   0.000012     call s:check_focus(a:options, fallback_winid)
                              elseif a:position.name ==# 'right'
                                wincmd b
                                execute 'silent keepalt vertical botright sb '.a:bufnr
                                call coc_explorer#resize(a:bufnr, a:position, a:options)
                                call s:check_focus(a:options, fallback_winid)
                              elseif a:position.name ==# 'floating'
                                call coc_explorer#float#resume(a:bufnr, a:options)
                              else
                                throw 'No support position "'.a:position.name.'"'
    2              0.000002   endif

FUNCTION  ale#util#BinarySearch()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/util.vim:232
Called 182 times
Total time:   0.008610
 Self time:   0.008610

count  total (s)   self (s)
  182              0.000227     let l:min = 0
  182              0.000391     let l:max = len(a:loclist) - 1
                            
  348              0.000397     while 1
  348              0.000455         if l:max < l:min
  181              0.000139             return -1
  167              0.000068         endif
                            
  167              0.000330         let l:mid = (l:min + l:max) / 2
  167              0.000333         let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
  167              0.000285         if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
  167              0.000240         elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
  167              0.000227         elseif l:item.lnum < a:line
   67              0.000085             let l:min = l:mid + 1
  100              0.000100         elseif l:item.lnum > a:line
   99              0.000131             let l:max = l:mid - 1
    1              0.000000         else
                                        " This part is a small sequential search.
    1              0.000001             let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
    1              0.000002             while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
    1              0.000000             endwhile
                            
                                        " Find the last problem on or before this column.
    1              0.000003             while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
    1              0.000000             endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
    1              0.000002             let l:item_column = a:loclist[l:index].col
                            
    1              0.000003             while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
    1              0.000000             endwhile
                            
    1              0.000001             return l:index
  166              0.000085         endif
  166              0.000110     endwhile

FUNCTION  ale#cursor#TruncatedEcho()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/cursor.vim:21
Called 1 time
Total time:   0.000932
 Self time:   0.000061

count  total (s)   self (s)
    1              0.000001     let l:message = a:original_message
                                " Change tabs to spaces.
    1              0.000003     let l:message = substitute(l:message, "\t", ' ', 'g')
                                " Remove any newlines in the message.
    1              0.000002     let l:message = substitute(l:message, "\n", '', 'g')
                                " Convert indentation groups into single spaces for better legibility when
                                " put on a single line
    1              0.000005     let l:message = substitute(l:message, ' \+', ' ', 'g')
                            
                                " We need to remember the setting for shortmess and reset it again.
    1              0.000001     let l:shortmess_options = &l:shortmess
                            
    1              0.000000     try
    1              0.000002         let l:cursor_position = getpos('.')
                            
                                    " The message is truncated and saved to the history.
    1   0.000009   0.000007         silent! setlocal shortmess+=T
                            
    1              0.000001         try
    1   0.000875   0.000011             call ale#cursor#Echom(l:message)
                                    catch /^Vim\%((\a\+)\)\=:E523/
                                        " Fallback into manual truncate (#1987)
                                        let l:winwidth = winwidth(0)
                            
                                        if l:winwidth < strdisplaywidth(l:message)
                                            " Truncate message longer than window width with trailing '...'
                                            let l:message = l:message[:l:winwidth - 4] . '...'
                                        endif
                            
                                        exec 'echomsg l:message'
                                    catch /E481/
                                        " Do nothing if running from a visual selection.
    1              0.000001         endtry
                            
                                    " Reset the cursor position if we moved off the end of the line.
                                    " Using :norm and :echomsg can move the cursor off the end of the
                                    " line.
    1              0.000003         if l:cursor_position != getpos('.')
                                        call setpos('.', l:cursor_position)
    1              0.000000         endif
    1              0.000001     finally
    1   0.000010   0.000005         let &l:shortmess = l:shortmess_options
    1              0.000001     endtry

FUNCTION  ale#engine#RunLinters()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/engine.vim:708
Called 1 time
Total time:   0.002459
 Self time:   0.000028

count  total (s)   self (s)
                                " Initialise the buffer information if needed.
    1   0.000014   0.000005     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
                            
    1   0.002443   0.000020     call s:GetLintFileValues(   s:GetLintFileSlots(a:buffer, a:linters),   {       slots -> s:RunLinters(           a:buffer,           a:linters,           slots,           a:should_lint_file,           l:new_buffer,       )   })

FUNCTION  coc#util#variables()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/util.vim:223
Called 1 time
Total time:   0.000128
 Self time:   0.000128

count  total (s)   self (s)
    1              0.000003   let info = getbufinfo(a:bufnr)
    1              0.000007   let variables = empty(info) ? {} : copy(info[0]['variables'])
   15              0.000032   for key in keys(variables)
   14              0.000043     if key !~# '\v^coc'
   14              0.000021       unlet variables[key]
   14              0.000005     endif
   15              0.000006   endfor
    1              0.000002   return variables

FUNCTION  ale#util#FindItemAtCursor()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/util.vim:485
Called 182 times
Total time:   0.013010
 Self time:   0.004401

count  total (s)   self (s)
  182              0.000999     let l:info = get(g:ale_buffer_info, a:buffer, {})
  182              0.000490     let l:loclist = get(l:info, 'loclist', [])
  182              0.000482     let l:pos = getpos('.')
  182   0.010002   0.001392     let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
  182              0.000440     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
  182              0.000285     return [l:info, l:loc]

FUNCTION  ale#util#StartPartialTimer()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/util.vim:460
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000006     let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
    1              0.000003     let s:partial_timers[l:timer_id] = [a:callback, a:args]
                            
    1              0.000001     return l:timer_id

FUNCTION  coc_explorer#util#do_autocmd()
    Defined: ~/.config/coc/extensions/node_modules/coc-explorer/autoload/coc_explorer/util.vim:61
Called 8 times
Total time:   0.000111
 Self time:   0.000111

count  total (s)   self (s)
    8              0.000081   if exists('#User#'.a:name)
                                exe 'doautocmd <nomodeline> User '.a:name
    8              0.000004   endif

FUNCTION  ale#command#InitData()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/command.vim:22
Called 3 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    3              0.000007     if !has_key(s:buffer_data, a:buffer)
    2              0.000007         let s:buffer_data[a:buffer] = {   'jobs': {},   'file_list': [],   'directory_list': [],}
    3              0.000001     endif

FUNCTION  ale#engine#SendResultsToNeovimDiagnostics()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/engine.vim:247
Called 1 time
Total time:   0.000254
 Self time:   0.000254

count  total (s)   self (s)
    1              0.000003     if !has('nvim-0.6')
                                    " We will warn the user on startup as well if they try to set
                                    " g:ale_use_neovim_diagnostics_api outside of a Neovim context.
                                    return
    1              0.000000     endif
                            
                                " Keep the Lua surface area really small in the VimL part of ALE,
                                " and just require the diagnostics.lua module on demand.
    1              0.000016     let l:SendDiagnostics = luaeval('require("ale.diagnostics").sendAleResultsToDiagnostics')
    1              0.000232     call l:SendDiagnostics(a:buffer, a:loclist)

FUNCTION  <SNR>26_Remove_Matches()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:206
Called 255 times
Total time:   0.002186
 Self time:   0.002186

count  total (s)   self (s)
  255              0.000564   if exists('w:paren_hl_on') && w:paren_hl_on
    6              0.000011     while !empty(w:matchparen_ids)
    3              0.000014       silent! call remove(w:matchparen_ids, 0)->matchdelete()
    6              0.000004     endwhile
    3              0.000004     let w:paren_hl_on = 0
  255              0.000097   endif

FUNCTION  undotree#UndotreePersistUndo()
    Defined: ~/.local/share/nvim/lazy/undotree/autoload/undotree.vim:1472
Called 1 time
Total time:   0.000043
 Self time:   0.000034

count  total (s)   self (s)
    1   0.000012   0.000007     call s:log("undotree#UndotreePersistUndo(" . a:goSetUndofile . ")")
    1              0.000001     if ! &undofile
                                    if !isdirectory(g:undotree_UndoDir)
                                        call mkdir(g:undotree_UndoDir, 'p', 0700)
                                        call s:log(" > [Dir " . g:undotree_UndoDir . "] created.")
                                    endif
                                    exe "set undodir=" . fnameescape(g:undotree_UndoDir)
                                    call s:log(" > [set undodir=" . g:undotree_UndoDir . "] executed.")
                                    if filereadable(undofile(expand('%'))) || a:goSetUndofile
                                        setlocal undofile
                                        call s:log(" > [setlocal undofile] executed")
                                    endif
                                    if a:goSetUndofile
                                        silent! write
                                        echo "A persistence undo file has been created."
                                    endif
    1              0.000000     else
    1   0.000007   0.000003         call s:log(" > Undofile has been set. Do nothing.")
    1              0.000000     endif

FUNCTION  ale#command#ManageDirectory()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/command.vim:50
Called 1 time
Total time:   0.000015
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000012   0.000005     call ale#command#InitData(a:buffer)
    1              0.000003     call add(s:buffer_data[a:buffer].directory_list, a:directory)

FUNCTION  ale#linter#GetAll()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/linter.vim:278
Called 10 times
Total time:   0.000640
 Self time:   0.000424

count  total (s)   self (s)
                                " Don't return linters in the sandbox.
                                " Otherwise a sandboxed script could modify them.
   10   0.000256   0.000040     if ale#util#InSandbox()
                                    return []
   10              0.000003     endif
                            
   10              0.000015     let l:combined_linters = []
                            
   20              0.000023     for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
   10              0.000023         if !has_key(s:runtime_loaded_map, l:filetype)
                                        execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
                                        let s:runtime_loaded_map[l:filetype] = 1
   10              0.000004         endif
                            
   10              0.000054         call extend(l:combined_linters, get(s:linters, l:filetype, []))
   20              0.000015     endfor
                            
   10              0.000010     return l:combined_linters

FUNCTION  coc#util#tabnr_id()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/util.vim:410
Called 11 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
   11              0.000052   return s:is_vim ? coc#api#get_tabid(a:tabnr) : nvim_list_tabpages()[a:tabnr - 1]

FUNCTION  <SNR>71_Deduplicate()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/list.vim:57
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000001     let l:list = a:list
                            
    1              0.000003     call sort(l:list, function('ale#util#LocItemCompareWithText'))
    1              0.000002     call uniq(l:list, function('ale#util#LocItemCompareWithText'))
                            
    1              0.000001     return l:list

FUNCTION  ale#linter#ResolveFiletype()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/linter.vim:327
Called 10 times
Total time:   0.000557
 Self time:   0.000149

count  total (s)   self (s)
   10   0.000514   0.000107     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
   10              0.000018     if type(l:filetype) isnot v:t_list
   10              0.000012         return [l:filetype]
                                endif
                            
                                return l:filetype

FUNCTION  VimPythonExtend()
    Defined: ~/Software/vtags-3.11/vtags_vim_api.vim:34
Called 1 time
Total time:   0.000851
 Self time:   0.000851

count  total (s)   self (s)
    1              0.000003 if has('python')
                            python << EOF
                            import sys
                            import os
                            import vim
                            vtags_install_path = vim.eval('s:path')
                            assert(os.path.isdir(vtags_install_path))
                            sys.path.insert(0,vtags_install_path)
                            from Lib.ExceptionLib import *
                            
                            vim.command("let s:vtags_active = 0")
                            try:
                                from InlineLib.InlineAPI import *
                                vim.command("let s:vtags_active = 1")
                            except VtagsDBNotFoundExcept:
                                pass
                            except VtagsUnsupportFileExcept:
                                pass
                            
                            EOF
    1              0.000003 elseif has('python3')
    1              0.000001 python3 << EOF
                            import sys
                            import os
                            import vim
                            vtags_install_path = vim.eval('s:path')
                            assert(os.path.isdir(vtags_install_path))
                            sys.path.insert(0,vtags_install_path)
                            from Lib.ExceptionLib import *
                            
                            vim.command("let s:vtags_active = 0")
                            try:
                                from InlineLib.InlineAPI import *
                                vim.command("let s:vtags_active = 1")
                            except VtagsDBNotFoundExcept:
                                pass
                            except VtagsUnsupportFileExcept:
                                pass
                            
                            EOF
    1              0.000002 endif

FUNCTION  ale#util#Mode()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/util.vim:5
Called 197 times
Total time:   0.001086
 Self time:   0.001086

count  total (s)   self (s)
  197              0.000867     return call('mode', a:000)

FUNCTION  coc#notify#on_close()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/notify.vim:257
Called 4 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    4              0.000011   if index(s:winids, a:winid) >= 0
                                call filter(s:winids, 'v:val != '.a:winid)
                                call coc#notify#reflow()
    4              0.000001   endif

FUNCTION  ale#list#SetLists()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/list.vim:207
Called 1 time
Total time:   0.000030
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000004     if get(g:, 'ale_set_lists_synchronously') == 1|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
                                    call s:SetListsImpl(-1, a:buffer, a:loclist)
    1              0.000000     else
    1   0.000020   0.000009         call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
    1              0.000000     endif

FUNCTION  ale#util#InSandbox()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/util.vim:290
Called 209 times
Total time:   0.005535
 Self time:   0.003657

count  total (s)   self (s)
  209              0.000223     try
  209   0.004189   0.002311         let &l:equalprg=&l:equalprg
                                catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
  209              0.000163     endtry
                            
  209              0.000140     return 0

FUNCTION  ale#path#Simplify()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/path.vim:15
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000002     if has('unix')
    1              0.000004         let l:unix_path = substitute(a:path, '\\', '/', 'g')
                            
    1              0.000005         return substitute(simplify(l:unix_path), '^//\+', '/', 'g') " no-custom-checks
                                endif
                            
                                let l:win_path = substitute(a:path, '/', '\\', 'g')
                            
                                return substitute(simplify(l:win_path), '^\\\+', '\', 'g') " no-custom-checks

FUNCTION  coc#util#tabpages()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/util.vim:439
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000002   if s:is_vim
                                return coc#api#exec('list_tabpages', [])
    2              0.000001   endif
    2              0.000005   return nvim_list_tabpages()

FUNCTION  ale#util#GetLineCount()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/util.vim:84
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000015     return len(getbufline(a:buffer, 1, '$'))

FUNCTION  ale#engine#FixLocList()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/engine.vim:282
Called 1 time
Total time:   0.000227
 Self time:   0.000159

count  total (s)   self (s)
    1   0.000030   0.000005     let l:mappings = ale#GetFilenameMappings(a:buffer, a:linter_name)
                            
    1              0.000001     if !empty(l:mappings)
                                    " We need to apply reverse filename mapping here.
                                    let l:mappings = ale#filename_mapping#Invert(l:mappings)
    1              0.000000     endif
                            
    1              0.000001     let l:bufnr_map = {}
    1              0.000001     let l:new_loclist = []
                            
                                " Some errors have line numbers beyond the end of the file,
                                " so we need to adjust them so they set the error at the last line
                                " of the file instead.
    1   0.000020   0.000005     let l:last_line_number = ale#util#GetLineCount(a:buffer)
                            
    2              0.000002     for l:old_item in a:loclist
                                    " Copy the loclist item with some default values and corrections.
                                    "
                                    " line and column numbers will be converted to numbers.
                                    " The buffer will default to the buffer being checked.
                                    " The vcol setting will default to 0, a byte index.
                                    " The error type will default to 'E' for errors.
                                    " The error number will default to -1.
                                    "
                                    " The line number and text are the only required keys.
                                    "
                                    " The linter_name will be set on the errors so it can be used in
                                    " output, filtering, etc..
    1              0.000008         let l:item = {   'bufnr': a:buffer,   'text': l:old_item.text,   'lnum': str2nr(l:old_item.lnum),   'col': str2nr(get(l:old_item, 'col', 0)),   'vcol': 0,   'type': get(l:old_item, 'type', 'E'),   'nr': get(l:old_item, 'nr', -1),   'linter_name': a:linter_name,}
                            
    1              0.000001         if a:from_other_source
                                        let l:item.from_other_source = 1
    1              0.000000         endif
                            
    1              0.000001         if has_key(l:old_item, 'code')
                                        let l:item.code = l:old_item.code
    1              0.000000         endif
                            
    1              0.000002         let l:old_name = get(l:old_item, 'filename', '')
                            
                                    " Map parsed from output to local filesystem files.
    1              0.000002         if !empty(l:old_name) && !empty(l:mappings)
                                        let l:old_name = ale#filename_mapping#Map(l:old_name, l:mappings)
    1              0.000000         endif
                            
    1   0.000027   0.000008         if !empty(l:old_name) && !ale#path#IsTempName(l:old_name)
                                        " Use the filename given.
                                        " Temporary files are assumed to be for this buffer,
                                        " and the filename is not included then, because it looks bad
                                        " in the loclist window.
                                        let l:filename = l:old_name
                                        let l:item.filename = l:filename
                            
                                        if has_key(l:old_item, 'bufnr')
                                            " If a buffer number is also given, include that too.
                                            " If Vim detects that he buffer number is valid, it will
                                            " be used instead of the filename.
                                            let l:item.bufnr = l:old_item.bufnr
                                        elseif has_key(l:bufnr_map, l:filename)
                                            " Get the buffer number from the map, which can be faster.
                                            let l:item.bufnr = l:bufnr_map[l:filename]
                                        else
                                            " Look up the buffer number.
                                            let l:item.bufnr = bufnr(l:filename)
                                            let l:bufnr_map[l:filename] = l:item.bufnr
                                        endif
    1              0.000001         elseif has_key(l:old_item, 'bufnr')
                                        let l:item.bufnr = l:old_item.bufnr
    1              0.000000         endif
                            
    1              0.000001         if has_key(l:old_item, 'detail')
                                        let l:item.detail = l:old_item.detail
    1              0.000000         endif
                            
                                    " Pass on a end_col key if set, used for highlights.
    1              0.000001         if has_key(l:old_item, 'end_col')
                                        let l:item.end_col = str2nr(l:old_item.end_col)
    1              0.000000         endif
                            
    1              0.000001         if has_key(l:old_item, 'end_lnum')
                                        let l:item.end_lnum = str2nr(l:old_item.end_lnum)
                            
                                        " When the error ends after the end of the file, put it at the
                                        " end. This is only done for the current buffer.
                                        if l:item.bufnr == a:buffer && l:item.end_lnum > l:last_line_number
                                            let l:item.end_lnum = l:last_line_number
                                        endif
    1              0.000000         endif
                            
    1              0.000001         if has_key(l:old_item, 'sub_type')
                                        let l:item.sub_type = l:old_item.sub_type
    1              0.000000         endif
                            
    1              0.000001         if l:item.lnum < 1
                                        " When errors appear before line 1, put them at line 1.
                                        let l:item.lnum = 1
    1              0.000002         elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                        " When errors go beyond the end of the file, put them at the end.
                                        " This is only done for the current buffer.
                                        let l:item.lnum = l:last_line_number
    1              0.000001         elseif get(l:old_item, 'vcol', 0)
                                        " Convert virtual column positions to byte positions.
                                        " The positions will be off if the buffer has changed recently.
                                        let l:line = getbufline(a:buffer, l:item.lnum)[0]
                            
                                        let l:item.col = ale#util#Col(l:line, l:item.col)
                            
                                        if has_key(l:item, 'end_col')
                                            let l:end_line = get(l:item, 'end_lnum', l:line) != l:line   ? getbufline(a:buffer, l:item.end_lnum)[0]   : l:line
                            
                                            let l:item.end_col = ale#util#Col(l:end_line, l:item.end_col)
                                        endif
    1              0.000000         endif
                            
    1              0.000002         call add(l:new_loclist, l:item)
    2              0.000002     endfor
                            
    1   0.000014   0.000006     let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                            
    1              0.000001     if !empty(l:type_map)
                                    call s:RemapItemTypes(l:type_map, l:new_loclist)
    1              0.000000     endif
                            
    1              0.000001     return l:new_loclist

FUNCTION  coc#util#get_bufoptions()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/util.vim:465
Called 1 time
Total time:   0.000215
 Self time:   0.000082

count  total (s)   self (s)
    1              0.000005   if !bufloaded(a:bufnr) | return v:null | endif
    1              0.000002   let bufname = bufname(a:bufnr)
    1              0.000003   let buftype = getbufvar(a:bufnr, '&buftype')
    1              0.000009   let commandline = get(getbufinfo(a:bufnr)[0], 'command', 0) || bufname(a:bufnr) == '[Command Line]'
    1   0.000010   0.000005   let size = coc#util#bufsize(a:bufnr)
    1              0.000001   let lines = v:null
    1              0.000004   if getbufvar(a:bufnr, 'coc_enabled', 1) && (buftype == '' || buftype == 'acwrite' || getbufvar(a:bufnr, 'coc_force_attach', 0)) && size != -2 && size < a:max
    1              0.000011     let lines = getbufline(a:bufnr, 1, '$')
    1              0.000000   endif
    1   0.000166   0.000039   return { 'bufnr': a:bufnr, 'commandline': commandline, 'size': size, 'lines': lines, 'winid': bufwinid(a:bufnr), 'bufname': bufname, 'buftype': buftype, 'previewwindow': v:false, 'eol': getbufvar(a:bufnr, '&eol'), 'variables': coc#util#variables(a:bufnr), 'filetype': getbufvar(a:bufnr, '&filetype'), 'lisp': getbufvar(a:bufnr, '&lisp'), 'iskeyword': getbufvar(a:bufnr, '&iskeyword'), 'changedtick': getbufvar(a:bufnr, 'changedtick'), 'fullpath': empty(bufname) ? '' : fnamemodify(bufname, ':p'),}

FUNCTION  ale#engine#SetResults()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/engine.vim:184
Called 1 time
Total time:   0.000698
 Self time:   0.000075

count  total (s)   self (s)
    1   0.000013   0.000006     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
    1              0.000001     if g:ale_use_neovim_diagnostics_api
    1   0.000263   0.000008         call ale#engine#SendResultsToNeovimDiagnostics(a:buffer, a:loclist)
    1              0.000001     endif
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
    1              0.000003     if !g:ale_use_neovim_diagnostics_api && g:ale_set_signs
                                    call ale#sign#SetSigns(a:buffer, a:loclist)
    1              0.000000     endif
                            
    1              0.000002     if g:ale_set_quickfix || g:ale_set_loclist
    1   0.000037   0.000007         call ale#list#SetLists(a:buffer, a:loclist)
    1              0.000000     endif
                            
    1              0.000002     if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
                                    call ale#statusline#Update(a:buffer, a:loclist)
    1              0.000000     endif
                            
    1              0.000001     if !g:ale_use_neovim_diagnostics_api && g:ale_set_highlights
                                    call ale#highlight#SetHighlights(a:buffer, a:loclist)
    1              0.000000     endif
                            
    1              0.000002     if !g:ale_use_neovim_diagnostics_api&& (g:ale_virtualtext_cursor is# 'all' || g:ale_virtualtext_cursor == 2)
                                    call ale#virtualtext#SetTexts(a:buffer, a:loclist)
    1              0.000000     endif
                            
    1              0.000001     if l:linting_is_done
    1              0.000001         if g:ale_echo_cursor
                                        " Try and echo the warning now.
                                        " This will only do something meaningful if we're in normal mode.
    1   0.000195   0.000004             call ale#cursor#EchoCursorWarning()
    1              0.000000         endif
                            
    1              0.000002         if !g:ale_use_neovim_diagnostics_api&& (g:ale_virtualtext_cursor is# 'current' || g:ale_virtualtext_cursor == 1)
                                        " Try and show the warning now.
                                        " This will only do something meaningful if we're in normal mode.
                                        call ale#virtualtext#ShowCursorWarning()
    1              0.000000         endif
                            
                                    " Reset the save event marker, used for opening windows, etc.
    1              0.000003         call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Set a marker showing how many times a buffer has been checked.
    1              0.000003         call setbufvar(   a:buffer,   'ale_linted',   getbufvar(a:buffer, 'ale_linted', 0) + 1)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
    1   0.000147   0.000008         call ale#command#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
    1   0.000006   0.000004         silent doautocmd <nomodeline> User ALELintPost
    1              0.000000     endif

FUNCTION  <SNR>61_RunLinters()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/engine.vim:667
Called 1 time
Total time:   0.002352
 Self time:   0.000060

count  total (s)   self (s)
    1   0.000055   0.000006     call s:StopCurrentJobs(a:buffer, a:should_lint_file, a:slots)
    1   0.000030   0.000007     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
    1   0.000012   0.000005     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
    1   0.000002   0.000002     silent doautocmd <nomodeline> User ALELintPre
                            
    2              0.000002     for [l:lint_file, l:linter] in a:slots
                                    " Only run lint_file linters if we should.
    1              0.000001         if !l:lint_file || a:should_lint_file
    1   0.002124   0.000005             if s:RunLinter(a:buffer, l:linter, l:lint_file)
                                            " If a single linter ran, we shouldn't clear everything.
    1              0.000001                 let l:can_clear_results = 0
    1              0.000000             endif
                                    else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
                                        let l:can_clear_results = 0
    1              0.000000         endif
    2              0.000002     endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
    1              0.000001     if l:can_clear_results
                                    call ale#engine#SetResults(a:buffer, [])
    1              0.000001     elseif a:new_buffer
    1   0.000105   0.000012         call s:AddProblemsFromOtherBuffers(   a:buffer,   map(copy(a:slots), 'v:val[1]'))
    1              0.000000     endif

FUNCTION  ale#util#GetMatches()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/util.vim:325
Called 1 time
Total time:   0.000129
 Self time:   0.000129

count  total (s)   self (s)
    1              0.000001     let l:matches = []
    1              0.000003     let l:lines = type(a:lines) is v:t_list ? a:lines : [a:lines]
    1              0.000003     let l:patterns = type(a:patterns) is v:t_list ? a:patterns : [a:patterns]
                            
    8              0.000005     for l:line in l:lines
   13              0.000009         for l:pattern in l:patterns
    7              0.000053             let l:match = matchlist(l:line, l:pattern)
                            
    7              0.000007             if !empty(l:match)
    1              0.000002                 call add(l:matches, l:match)
    1              0.000001                 break
    6              0.000002             endif
   13              0.000004         endfor
    8              0.000003     endfor
                            
    1              0.000001     return l:matches

FUNCTION  <SNR>27_LocalBrowse()
    Defined: /usr/share/nvim/runtime/plugin/netrwPlugin.vim:105
Called 11 times
Total time:   0.000309
 Self time:   0.000309

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
   11              0.000019   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
   11              0.000003   endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
   11              0.000043   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
   11              0.000068   elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               " Jul 13, 2021: for whatever reason, preceding the following call with
                               " a   sil!  causes an unbalanced if-endif vim error
                               call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
   11              0.000003   else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
   11              0.000003   endif
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  ale#command#CreateTempFile()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/command.vim:110
Called 1 time
Total time:   0.000145
 Self time:   0.000085

count  total (s)   self (s)
    1              0.000001     if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
                                    return 0
    1              0.000000     endif
                            
                                " Use an existing list of lines of input if we have it, or get the lines
                                " from the file.
    1              0.000009     let l:lines = a:input isnot v:null ? a:input : getbufline(a:buffer, 1, '$')
                            
    1              0.000002     let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
    1              0.000055     call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
    1   0.000023   0.000007     call ale#command#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
    1   0.000051   0.000006     call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                            
    1              0.000001     return 1

FUNCTION  <SNR>17_request()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/client.vim:154
Called 3 times
Total time:   0.003327
 Self time:   0.003312

count  total (s)   self (s)
    3   0.000036   0.000021   let channel = coc#client#get_channel(self)
    3              0.000006   if empty(channel) | return '' | endif
    3              0.000002   try
    3              0.000002     if s:is_vim
                                  let res = ch_evalexpr(channel, [a:method, a:args], {'timeout': 60 * 1000})
                                  if type(res) == 1 && res ==# ''
                                    throw 'request '.a:method. ' '.string(a:args).' timeout after 60s'
                                  endif
                                  let [l:errmsg, res] =  res
                                  if !empty(l:errmsg)
                                    throw 'Error on "'.a:method.'" request: '.l:errmsg
                                  else
                                    return res
                                  endif
    3              0.000001     else
    3              0.003181       return call('rpcrequest', [channel, a:method] + a:args)
                                endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0) | return | endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  if s:is_vim
                                    throw v:exception
                                  else
                                    throw 'Error on request: '.v:exception
                                  endif
                                endif
    3              0.000003   endtry

FUNCTION  ale#engine#HandleLoclist()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/engine.vim:108
Called 1 time
Total time:   0.001048
 Self time:   0.000044

count  total (s)   self (s)
    1              0.000004     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
    1              0.000001     if empty(l:info)
                                    return
    1              0.000000     endif
                            
    1              0.000001     if !a:from_other_source
                                    " Remove this linter from the list of active linters.
                                    " This may have already been done when the job exits.
    1              0.000002         call filter(l:info.active_linter_list, 'v:val.name isnot# a:linter_name')
    1              0.000000     endif
                            
                                " Make some adjustments to the loclists to fix common problems, and also
                                " to set default values for loclist items.
    1   0.000236   0.000009     let l:linter_loclist = ale#engine#FixLocList(   a:buffer,   a:linter_name,   a:from_other_source,   a:loclist,)
                            
                                " Remove previous items for this linter.
    1              0.000002     call filter(l:info.loclist, 'v:val.linter_name isnot# a:linter_name')
                            
                                " We don't need to add items or sort the list when this list is empty.
    1              0.000001     if !empty(l:linter_loclist)
                                    " Add the new items.
    1              0.000002         call extend(l:info.loclist, l:linter_loclist)
                            
                                    " Sort the loclist again.
                                    " We need a sorted list so we can run a binary search against it
                                    " for efficient lookup of the messages in the cursor handler.
    1              0.000002         call sort(l:info.loclist, 'ale#util#LocItemCompare')
    1              0.000000     endif
                            
    1   0.000083   0.000004     if ale#ShouldDoNothing(a:buffer)
                                    return
    1              0.000000     endif
                            
    1   0.000705   0.000007     call ale#engine#SetResults(a:buffer, l:info.loclist)

FUNCTION  coc_explorer#util#open_file()
    Defined: ~/.config/coc/extensions/node_modules/coc-explorer/autoload/coc_explorer/util.vim:109
Called 1 time
Total time:   0.032912
 Self time:   0.001556

count  total (s)   self (s)
    1              0.000015   let cur_fullpath = expand('%:p')
    1              0.000002   if a:cmd == 'edit'
                                if cur_fullpath == a:filepath
                                  return
                                endif
                                if &modified && !&hidden
                                  echoerr 'Vim hidden option is off'
                                  return
                                endif
    1              0.000000   endif
    1              0.000001   let path = a:filepath
    1              0.000001   if a:is_relative
                                let path = fnamemodify(path, ':.')
    1              0.000000   endif
    1              0.000003   let path = fnameescape(path)
    1   0.032880   0.001523   execute a:cmd . ' ' . path

FUNCTION  <SNR>48_log()
    Defined: ~/.local/share/nvim/lazy/undotree/autoload/undotree.vim:201
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000002     if s:debug
                                    exec 'redir >> ' . s:debugfile
                                    silent echon strftime('%H:%M:%S') . ': ' . string(a:msg) . "\n"
                                    redir END
    2              0.000001     endif

FUNCTION  ale#history#Get()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/history.vim:8
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    2              0.000007     return copy(getbufvar(a:buffer, 'ale_history', []))

FUNCTION  <SNR>61_GetLintFileSlots()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/engine.vim:620
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000001     let l:linter_slots = []
                            
    2              0.000002     for l:linter in a:linters
    1              0.000001         let l:LintFile = l:linter.lint_file
                            
    1              0.000002         if type(l:LintFile) is v:t_func
                                        let l:LintFile = l:LintFile(a:buffer)
    1              0.000000         endif
                            
    1              0.000002         call add(l:linter_slots, [l:LintFile, l:linter])
    2              0.000001     endfor
                            
    1              0.000001     return l:linter_slots

FUNCTION  coc_explorer#win#set_width()
    Defined: ~/.config/coc/extensions/node_modules/coc-explorer/autoload/coc_explorer/win.vim:2
Called 2 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    2              0.000004     if win_id2win(a:win_id) == 0
                                  return
    2              0.000001     endif
    2              0.000017     call nvim_win_set_width(a:win_id, a:width)

FUNCTION  ale#path#IsTempName()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/path.vim:130
Called 1 time
Total time:   0.000020
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000019   0.000007     return ale#path#Simplify(a:filename)[:len(s:temp_dir) - 1] is# s:temp_dir

FUNCTION  ale#history#Add()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/history.vim:12
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000001     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
    1              0.000000     endif
                            
    1              0.000002     let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
    1              0.000002     if len(l:history) >= g:ale_max_buffer_history_size
                                    let l:history = l:history[1:]
    1              0.000000     endif
                            
    1              0.000003     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
    1              0.000003     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  ale#util#JoinNeovimOutput()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/util.vim:60
Called 2 times
Total time:   0.000139
 Self time:   0.000113

count  total (s)   self (s)
    2              0.000003     if a:mode is# 'raw'
                                    call a:callback(a:job, join(a:data, "\n"))
                            
                                    return ''
    2              0.000001     endif
                            
    2              0.000007     let l:lines = a:data[:-2]
                            
    2              0.000004     if len(a:data) > 1
    1              0.000004         let l:lines[0] = a:last_line . l:lines[0]
    1              0.000002         let l:new_last_line = a:data[-1]
    1              0.000000     else
    1              0.000002         let l:new_last_line = a:last_line . get(a:data, 0, '')
    2              0.000001     endif
                            
    9              0.000011     for l:line in l:lines
    7   0.000073   0.000047         call a:callback(a:job, l:line)
    9              0.000006     endfor
                            
    2              0.000002     return l:new_last_line

FUNCTION  <SNR>69_StopCursorTimer()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/cursor.vim:67
Called 196 times
Total time:   0.001255
 Self time:   0.001255

count  total (s)   self (s)
  196              0.000273     if s:cursor_timer != -1
  182              0.000392         call timer_stop(s:cursor_timer)
  182              0.000205         let s:cursor_timer = -1
  196              0.000121     endif

FUNCTION  <SNR>16_visible_ranges()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/util.vim:630
Called 1 time
Total time:   0.001224
 Self time:   0.001224

count  total (s)   self (s)
    1              0.000007   let info = getwininfo(a:winid)[0]
    1              0.000002   let res = []
    1              0.000004   if !has_key(info, 'topline') || !has_key(info, 'botline')
                                return res
    1              0.000001   endif
    1              0.000002   let begin = 0
    1              0.000002   let curr = info['topline']
    1              0.000002   let max = info['botline']
    1              0.000002   if win_getid() != a:winid
                                return [[curr, max]]
    1              0.000001   endif
   66              0.000070   while curr <= max
   65              0.000149     let closedend = foldclosedend(curr)
   65              0.000074     if closedend == -1
   58              0.000107       let begin = begin == 0 ? curr : begin
   58              0.000065       if curr == max
    1              0.000003         call add(res, [begin, curr])
   58              0.000028       endif
   58              0.000077       let curr = curr + 1
    7              0.000003     else
    7              0.000007       if begin != 0
    7              0.000022         call add(res, [begin, curr - 1])
    7              0.000023         let begin = closedend + 1
    7              0.000004       endif
    7              0.000010       let curr = closedend + 1
   65              0.000028     endif
   66              0.000031   endwhile
    1              0.000002   return res

FUNCTION  ale#linter#GetExecutable()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/linter.vim:421
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000001     let l:Executable = a:linter.executable
                            
    1              0.000003     return type(l:Executable) is v:t_func   ? l:Executable(a:buffer)   : l:Executable

FUNCTION  ale_linters#verilog#verilator#GetCommand()
    Defined: ~/.local/share/nvim/lazy/ale/ale_linters/verilog/verilator.vim:9
Called 1 time
Total time:   0.000018
 Self time:   0.000008

count  total (s)   self (s)
                                " the path to the current file is systematically added to the search path
    1   0.000016   0.000006     return 'verilator --lint-only -Wall -Wno-DECLFILENAME '   . '-I%s:h '   . ale#Var(a:buffer, 'verilog_verilator_options') .' '   . '%t'

FUNCTION  <SNR>14_HandleWinClosed()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/plugin/coc.vim:298
Called 4 times
Total time:   0.000602
 Self time:   0.000062

count  total (s)   self (s)
    4   0.000241   0.000021   call coc#float#on_close(a:winid)
    4   0.000045   0.000020   call coc#notify#on_close(a:winid)
    4   0.000311   0.000016   call s:Autocmd('WinClosed', a:winid)

FUNCTION  ale#job#PrepareCommand()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/job.vim:175
Called 1 time
Total time:   0.000051
 Self time:   0.000043

count  total (s)   self (s)
    1   0.000012   0.000004     let l:wrapper = ale#Var(a:buffer, 'command_wrapper')
                            
                                " The command will be executed in a subshell. This fixes a number of
                                " issues, including reading the PATH variables correctly, %PATHEXT%
                                " expansion on Windows, etc.
                                "
                                " NeoVim handles this issue automatically if the command is a String,
                                " but we'll do this explicitly, so we use the same exact command for both
                                " versions.
    1              0.000003     let l:command = !empty(l:wrapper) ? s:PrepareWrappedCommand(l:wrapper, a:command) : a:command
                            
                                " If a custom shell is specified, use that.
    1              0.000001     if exists('b:ale_shell')
                                    let l:ale_shell = b:ale_shell
    1              0.000001     elseif exists('g:ale_shell')
                                    let l:ale_shell = g:ale_shell
    1              0.000000     endif
                            
    1              0.000001     if exists('l:ale_shell')
                                    let l:shell_arguments = get(b:, 'ale_shell_arguments', get(g:, 'ale_shell_arguments', &shellcmdflag))
                            
                                    return split(l:ale_shell) + split(l:shell_arguments) + [l:command]
    1              0.000000     endif
                            
    1              0.000002     if has('win32')
                                    return 'cmd /s/c "' . l:command . '"'
    1              0.000000     endif
                            
    1              0.000006     if &shell =~? 'fish$\|pwsh$'
                                    return ['/bin/sh', '-c', l:command]
    1              0.000000     endif
                            
    1              0.000011     return split(&shell) + split(&shellcmdflag) + [l:command]

FUNCTION  ale#util#GetFunction()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/util.vim:88
Called 4 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    4              0.000010     if type(a:string_or_ref) is v:t_string
    1              0.000002         return function(a:string_or_ref)
    3              0.000001     endif
                            
    3              0.000003     return a:string_or_ref

FUNCTION  ale#util#Tempname()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/util.vim:301
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000001     let l:clear_tempdir = 0
                            
    1              0.000004     if exists('$TMPDIR') && empty($TMPDIR)
                                    let l:clear_tempdir = 1
                                    let $TMPDIR = '/tmp'
    1              0.000000     endif
                            
    1              0.000000     try
    1              0.000006         let l:name = tempname() " no-custom-checks
    1              0.000001     finally
    1              0.000001         if l:clear_tempdir
                                        let $TMPDIR = ''
    1              0.000000         endif
    1              0.000001     endtry
                            
    1              0.000001     return l:name

FUNCTION  coc#rpc#notify()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/rpc.vim:189
Called 310 times
Total time:   0.024445
 Self time:   0.003997

count  total (s)   self (s)
  310   0.003789   0.001405   if !coc#rpc#ready()
                                return ''
  310              0.000086   endif
  310   0.019917   0.001853   call s:client['notify'](a:method, a:args)
  310              0.000214   return ''

FUNCTION  ale#GetLocItemMessage()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale.vim:253
Called 2 times
Total time:   0.000096
 Self time:   0.000096

count  total (s)   self (s)
    2              0.000003     let l:msg = a:format_string
    2              0.000003     let l:severity = g:ale_echo_msg_warning_str
    2              0.000003     let l:code = get(a:item, 'code', '')
    2              0.000004     let l:type = get(a:item, 'type', 'E')
    2              0.000004     let l:linter_name = get(a:item, 'linter_name', '')
    2              0.000003     let l:code_repl = !empty(l:code) ? '\=submatch(1) . l:code . submatch(2)' : ''
                            
    2              0.000002     if l:type is# 'E'
    1              0.000001         let l:severity = g:ale_echo_msg_error_str
    1              0.000001     elseif l:type is# 'I'
                                    let l:severity = g:ale_echo_msg_info_str
    2              0.000001     endif
                            
                                " Replace special markers with certain information.
                                " \=l:variable is used to avoid escaping issues.
    2              0.000025     let l:msg = substitute(l:msg, '\v\%([^\%]*)code([^\%]*)\%', l:code_repl, 'g')
    2              0.000008     let l:msg = substitute(l:msg, '\V%severity%', '\=l:severity', 'g')
    2              0.000006     let l:msg = substitute(l:msg, '\V%type%', '\=l:type', 'g')
    2              0.000007     let l:msg = substitute(l:msg, '\V%linter%', '\=l:linter_name', 'g')
                                " Replace %s with the text.
    2              0.000008     let l:msg = substitute(l:msg, '\V%s', '\=a:item.text', 'g')
                                " Windows may insert carriage return line endings (^M), strip these characters.
    2              0.000005     let l:msg = substitute(l:msg, '\r', '', 'g')
                            
    2              0.000002     return l:msg

FUNCTION  <SNR>14_HandleWinScrolled()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/plugin/coc.vim:291
Called 16 times
Total time:   0.001486
 Self time:   0.000165

count  total (s)   self (s)
   16              0.000057   if getwinvar(a:winid, 'float', 0)
                                call coc#float#nvim_scrollbar(a:winid)
   16              0.000007   endif
   16   0.001386   0.000065   call s:Autocmd('WinScrolled', a:winid)

FUNCTION  coc#util#get_loaded_bufs()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/util.vim:414
Called 4 times
Total time:   0.000231
 Self time:   0.000231

count  total (s)   self (s)
    4              0.000224   return map(getbufinfo({'bufloaded': 1}),'v:val["bufnr"]')

FUNCTION  ale#linter#GetCwd()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/linter.vim:429
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000002     let l:Cwd = get(a:linter, 'cwd', v:null)
                            
    1              0.000002     return type(l:Cwd) is v:t_func ? l:Cwd(a:buffer) : l:Cwd

FUNCTION  ale#command#StopJobs()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/command.vim:261
Called 2 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000007     let l:info = get(s:buffer_data, a:buffer, {})
                            
    2              0.000002     if !empty(l:info)
                                    let l:new_map = {}
                            
                                    for [l:job_id, l:job_type] in items(l:info.jobs)
                                        let l:job_id = str2nr(l:job_id)
                            
                                        if a:job_type is# 'all' || a:job_type is# l:job_type
                                            call ale#job#Stop(l:job_id)
                                        else
                                            let l:new_map[l:job_id] = l:job_type
                                        endif
                                    endfor
                            
                                    let l:info.jobs = l:new_map
    2              0.000001     endif

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
    Defined: ~/.local/share/nvim/lazy/ale/autoload/ale/cursor.vim:117
Called 196 times
Total time:   0.010458
 Self time:   0.007287

count  total (s)   self (s)
  196              0.000532     let l:buffer = bufnr('')
                            
  196              0.000309     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
  196              0.000086     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
  196              0.000381     if mode(1) isnot# 'n'
                                    return
  196              0.000055     endif
                            
  196   0.002141   0.000886     call s:StopCursorTimer()
                            
  196              0.000755     let l:pos = getpos('.')[0:2]
                            
  196              0.000357     if !exists('w:last_pos')
    3              0.000005         let w:last_pos = [0, 0, 0]
  196              0.000058     endif
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
  196              0.000261     if l:pos != w:last_pos
  182   0.002736   0.000821         let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
  182              0.000263         let w:last_pos = l:pos
  182              0.000820         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
  196              0.000073     endif

FUNCTION  coc#string#byte_index()
    Defined: ~/.local/share/nvim/lazy/coc.nvim/autoload/coc/string.vim:35
Called 944 times
Total time:   0.230822
 Self time:   0.230822

count  total (s)   self (s)
  944              0.000776   if a:character <= 0
   76              0.000041     return 0
  868              0.000235   endif
                              " code unit index
  868              0.000567   let i = 0
  868              0.000597   let len = 0
38384              0.069623   for char in split(a:line, '\zs')
38384              0.048207     let i += char2nr(char) > 65535 ? 2 : 1
38384              0.041550     let len += strlen(char)
38384              0.026332     if i >= a:character
  868              0.000295       break
37516              0.008496     endif
38384              0.013129   endfor
  868              0.000582   return len

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  472   0.280796   0.038333  coc#highlight#ranges()
  944   0.230822             coc#string#byte_index()
  182   0.048700   0.012600  ale#cursor#EchoCursorWarning()
    1   0.032912   0.001556  coc_explorer#util#open_file()
  293   0.027010   0.003704  <SNR>14_Autocmd()
  310   0.024445   0.003997  coc#rpc#notify()
  197   0.023249   0.015172  ale#ShouldDoNothing()
  310   0.018064   0.016592  <SNR>17_notify()
  233   0.017558   0.015606  <SNR>26_Highlight_Matching_Pair()
  182   0.013010   0.004401  ale#util#FindItemAtCursor()
  472   0.010574             coc#highlight#add_highlight()
  196   0.010458   0.007287  ale#cursor#EchoCursorWarningWithDelay()
    2   0.009026   0.000268  coc_explorer#resume()
  182   0.008610             ale#util#BinarySearch()
    8   0.007641             provider#python3#Call()
   10   0.005739   0.000691  <SNR>50_Lint()
  209   0.005535   0.003657  ale#util#InSandbox()
   14   0.004918   0.000508  ale#Queue()
    3   0.003805   0.000057  ale#events#LintOnEnter()
    3   0.003404   0.000048  coc#rpc#request()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  944              0.230822  coc#string#byte_index()
  472   0.280796   0.038333  coc#highlight#ranges()
  310   0.018064   0.016592  <SNR>17_notify()
  233   0.017558   0.015606  <SNR>26_Highlight_Matching_Pair()
  197   0.023249   0.015172  ale#ShouldDoNothing()
  182   0.048700   0.012600  ale#cursor#EchoCursorWarning()
  472              0.010574  coc#highlight#add_highlight()
  182              0.008610  ale#util#BinarySearch()
    8              0.007641  provider#python3#Call()
  196   0.010458   0.007287  ale#cursor#EchoCursorWarningWithDelay()
  182   0.013010   0.004401  ale#util#FindItemAtCursor()
  310   0.024445   0.003997  coc#rpc#notify()
  293   0.027010   0.003704  <SNR>14_Autocmd()
  209   0.005535   0.003657  ale#util#InSandbox()
    3   0.003327   0.003312  <SNR>17_request()
  313              0.002414  coc#rpc#ready()
  226              0.002336  ale#Var()
  255              0.002186  <SNR>26_Remove_Matches()
   13   0.002136   0.001945  coc_explorer#util#buf_set_lines_skip_cursor()
  197              0.001696  ale#FileTooLarge()

